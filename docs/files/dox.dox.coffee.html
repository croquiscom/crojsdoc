<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CroJSDoc - dox/dox.coffee</title><script>if (location.protocol.match(/^http/) && location.pathname.match('\.html') === null && location.pathname.slice(-1) !== '/') {
  location.href = location.href + '/';
}</script><link href="../bootstrap-3.2.0-dist/css/bootstrap.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]><script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script><script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]--><link href="../google-code-prettify/prettify.css" rel="stylesheet" type="text/css"><link href="../style.css" rel="stylesheet" type="text/css"></head><body data-spy="scroll" data-target=".sidebar"><nav class="navbar navbar-default navbar-fixed-top" role="navigation"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#top-navigation-collapse"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><div class="collapse navbar-collapse" id="top-navigation-collapse"><ul class="nav navbar-nav"><li><a href="../index.html">Home</a></li><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Guides <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../guides/ListOfTags.html">List of tags</a></li><li><a href="../guides/SetupGithubPages.html">Setup github pages</a></li><li><a href="../guides/SpecifyingReturns.html">Specifying returns</a></li><li><a href="../guides/SpecifyingTypes.html">Specifying types</a></li></ul></li><li><a href="../modules/index.html">Modules</a></li><li><a href="../classes/index.html">Classes</a></li><li><a href="../restapis.html">REST APIs</a></li><li class="dropdown active"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Files - dox/dox.coffee <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../files/api.js.html">api.js</a></li><li><a href="../files/cli.coffee.html">cli.coffee</a></li><li><a href="../files/collect.coffee.html">collect.coffee</a></li><li><a href="../files/example.coffee.html">example.coffee</a></li><li><a href="../files/example.js.html">example.js</a></li><li><a href="../files/plugin.coffee.html">plugin.coffee</a></li><li><a href="../files/render.coffee.html">render.coffee</a></li><li><a href="../files/dox.dox.coffee.html">dox/dox.coffee</a></li><li><a href="../files/dox.dox_coffee.coffee.html">dox/dox_coffee.coffee</a></li><li><a href="../files/dox.index.coffee.html">dox/index.coffee</a></li><li><a href="../files/dox.utils.coffee.html">dox/utils.coffee</a></li><li><a href="../files/types.code_context.coffee.html">types/code_context.coffee</a></li><li><a href="../files/types.comment.coffee.html">types/comment.coffee</a></li><li><a href="../files/types.content.coffee.html">types/content.coffee</a></li><li><a href="../files/types.options.coffee.html">types/options.coffee</a></li><li><a href="../files/types.result.coffee.html">types/result.coffee</a></li><li><a href="../files/types.tag.coffee.html">types/tag.coffee</a></li></ul></li></ul><div class="options"><label class="checkbox"><input id="options-private" type="checkbox"> Private </label></div></div></div></nav><div class="container-fluid content"><div class="row"><div class="hidden-xs sidebar col-sm-3" data-spy="affix"><div class="cormo-sidenav"><div class="panel panel-default"><div class="panel-collapse collapse in" id="undefined_body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/api.js.html">api.js</a></li><li><a href="../files/cli.coffee.html">cli.coffee</a></li><li><a href="../files/collect.coffee.html">collect.coffee</a></li><li><a href="../files/example.coffee.html">example.coffee</a></li><li><a href="../files/example.js.html">example.js</a></li><li><a href="../files/plugin.coffee.html">plugin.coffee</a></li><li><a href="../files/render.coffee.html">render.coffee</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#dox__body">dox/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="dox__body"><ul class="nav nav-pills nav-stacked"><li class="active"><a href="../files/dox.dox.coffee.html">dox.coffee</a></li><li><a href="../files/dox.dox_coffee.coffee.html">dox_coffee.coffee</a></li><li><a href="../files/dox.index.coffee.html">index.coffee</a></li><li><a href="../files/dox.utils.coffee.html">utils.coffee</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#types__body">types/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="types__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/types.code_context.coffee.html">code_context.coffee</a></li><li><a href="../files/types.comment.coffee.html">comment.coffee</a></li><li><a href="../files/types.content.coffee.html">content.coffee</a></li><li><a href="../files/types.options.coffee.html">options.coffee</a></li><li><a href="../files/types.result.coffee.html">result.coffee</a></li><li><a href="../files/types.tag.coffee.html">tag.coffee</a></li></ul></div></div></div></div><div class="col-sm-9 col-sm-offset-3"><section><h1>dox/dox.coffee</h1></section><pre class="prettyprint">##
# Module dependencies.
markdown = require 'marked'

renderer = new markdown.Renderer()

#renderer.heading = (text, level) -&gt;
#  '&lt;h' + level + '&gt;' + text + '&lt;/h' + level + '&gt;\n'

#renderer.paragraph = (text) -&gt;
#  '&lt;p&gt;' + text + '&lt;/p&gt;'

#renderer.br = () -&gt;
#  '&lt;br /&gt;'

markedOptions =
  renderer: renderer
  gfm: true
  tables: true
#  breaks: true
  pedantic: false
  sanitize: false
  smartLists: true
  smartypants: false

markdown.setOptions markedOptions

##
# Parse comments in the given string of `js`.
#
# @param {String} js
# @param {Object} options
# @return {Array}
# @see exports.parseComment
# @api public
exports.parseComments = (js, options = {}) -&gt;
  js = js.replace /\r\n/gm, '\n'

  comments = []
  skipSingleStar = options.skipSingleStar
  buf = ''
  withinMultiline = false
  withinSingle = false
  withinString = false
  linterPrefixes = options.skipPrefixes or ['jslint', 'jshint', 'eshint']
  skipPattern = new RegExp('^' + (options.raw ? '' : '&lt;p&gt;') + '('+ linterPrefixes.join('|') + ')')
  lineNum = 1
  lineNumStarting = 1

  i = 0
  len = js.length
  while i &lt; len
    # start comment
    if not withinMultiline and not withinSingle and not withinString and '/' is js[i] and '*' is js[i+1] and (not skipSingleStar or js[i+2] is '*')
      lineNumStarting = lineNum
      # code following the last comment
      if buf.trim().length
        comment = comments[comments.length - 1]
        if comment
          # Adjust codeStart for any vertical space between comment and code
          comment.codeStart += buf.match(/^(\s*)/)[0].split('\n').length - 1
          comment.code = code = exports.trimIndentation(buf).trim()
          comment.ctx = exports.parseCodeContext code, parentContext

          if comment.isConstructor and comment.ctx
              comment.ctx.type = 'constructor'

          # starting a new namespace
          if comment.ctx and (comment.ctx.type is 'prototype' or comment.ctx.type is 'class')
            parentContext = comment.ctx
          # reasons to clear the namespace
          # new property/method in a different constructor
          else if not parentContext or not comment.ctx or not comment.ctx.constructor or not parentContext.constructor or parentContext.constructor isnt comment.ctx.constructor
            parentContext = null
        buf = ''
      i += 2
      withinMultiline = true
      ignore = '!' is js[i]

      # if the current character isn't whitespace and isn't an ignored comment,
      # back up one character so we don't clip the contents
      if ' ' isnt js[i] and '\n' isnt js[i] and '\t' isnt js[i] and '!' isnt js[i]
        i--

    # end comment
    else if withinMultiline and not withinSingle and '*' is js[i] and '/' is js[i+1]
      i += 2
      buf = buf.replace /^[ \t]*\* ?/gm, ''
      comment = exports.parseComment buf, options
      comment.ignore = ignore
      comment.line = lineNumStarting
      comment.codeStart = lineNum + 1
      if not comment.description.full.match(skipPattern)
        comments.push comment
      withinMultiline = ignore = false
      buf = ''
    else if not withinSingle and not withinMultiline and not withinString and '/' is js[i] and '/' is js[i+1]
      withinSingle = true
      buf += js[i]
     else if withinSingle and not withinMultiline and '\n' is js[i]
      withinSingle = false
      buf += js[i]
    else if not withinSingle and not withinMultiline and ('\'' is js[i] or '&quot;' is js[i])
      withinString = not withinString
      buf += js[i]
    else
      buf += js[i]

    if '\n' is js[i]
      lineNum++

    i++

  if comments.length is 0
    comments.push
      tags: []
      description: full: '', summary: '', body: ''
      isPrivate: false
      isConstructor: false
      line: lineNumStarting

  # trailing code
  if buf.trim().length
    comment = comments[comments.length - 1]
    # Adjust codeStart for any vertical space between comment and code
    comment.codeStart += buf.match(/^(\s*)/)[0].split('\n').length - 1
    comment.code = code = exports.trimIndentation(buf).trim()
    comment.ctx = exports.parseCodeContext code, parentContext

  comments

##
# Removes excess indentation from string of code.
#
# @param {String} str
# @return {String}
# @api public
exports.trimIndentation = (str) -&gt;
  # Find indentation from first line of code.
  indent = str.match(/(?:^|\n)([ \t]*)[^\s]/)
  if indent
    # Replace indentation on all lines.
    str = str.replace(new RegExp('(^|\n)' + indent[1], 'g'), '$1')
  str

##
# Parse the given comment `str`.
#
# The comment object returned contains the following
#
#  - `tags`  array of tag objects
#  - `description` the first line of the comment
#  - `body` lines following the description
#  - `content` both the description and the body
#  - `isPrivate` true when &quot;@api private&quot; is used
#
# @param {String} str
# @param {Object} options
# @return {Object}
# @see exports.parseTag
# @api public
exports.parseComment = (str, options = {}) -&gt;
  str = str.trim()

  comment = tags: []
  raw = options.raw
  description = {}
  tags = str.split(/\n\s*@/)

  # A comment has no description
  if tags[0].charAt(0) is '@'
    tags.unshift ''

  # parse comment body
  description.full = tags[0]
  description.summary = description.full.split('\n\n')[0]
  description.body = description.full.split('\n\n').slice(1).join('\n\n')
  comment.description = description

  # parse tags
  if tags.length
    comment.tags = tags.slice(1).map(exports.parseTag)
    comment.isPrivate = comment.tags.some (tag) -&gt;
      'private' is tag.visibility
    comment.isConstructor = comment.tags.some (tag) -&gt;
      'constructor' is tag.type or 'augments' is tag.type
    comment.isClass = comment.tags.some (tag) -&gt;
      'class' is tag.type
    comment.isEvent = comment.tags.some (tag) -&gt;
      'event' is tag.type

    if not description.full or not description.full.trim()
      comment.tags.some (tag) -&gt;
        if 'description' is tag.type
          description.full = tag.full
          description.summary = tag.summary
          description.body = tag.body
          true

  # markdown
  if not raw
    description.full = markdown description.full
    description.summary = markdown description.summary
    description.body = markdown description.body
    comment.tags.forEach (tag) -&gt;
      if tag.description
        tag.description = markdown tag.description
      else
        tag.html = markdown tag.string

  comment

#TODO: Find a smarter way to do this
##
# Extracts different parts of a tag by splitting string into pieces separated by whitespace. If the white spaces are
# somewhere between curly braces (which is used to indicate param/return type in JSDoc) they will not be used to split
# the string. This allows to specify jsdoc tags without the need to eliminate all white spaces i.e. {number | string}
#
# @param str The tag line as a string that needs to be split into parts
# @returns {Array.&lt;string&gt;} An array of strings containing the parts
exports.extractTagParts = (str) -&gt;
  level = 0
  extract = ''
  split = []

  str.split('').forEach (c) -&gt;
    if c.match(/\s/) and level is 0
      split.push extract
      extract = ''
    else
      if c is '{'
        level++
      else if c is '}'
        level--

      extract += c

  split.push extract
  split.filter (str) -&gt;
    str.length &gt; 0

##
# Parse tag string &quot;@param {Array} name description&quot; etc.
#
# @param {String}
# @return {Object}
# @api public
exports.parseTag = (str) -&gt;
  tag = {}
  lines = str.split('\n')
  parts = exports.extractTagParts(lines[0])
  type = tag.type = parts.shift().replace('@', '').toLowerCase()
  matchType = new RegExp('^@?' + type + ' *')
  matchTypeStr = /^\{.+\}$/

  tag.string = str.replace(matchType, '')

  getMultilineDescription = -&gt;
    description = parts.join ' '
    if lines.length &gt; 1
      if description
        description += '\n'
      description += lines.slice(1).join('\n')
    description

  switch type
    when 'property', 'template', 'param'
      typeString = if matchTypeStr.test(parts[0]) then parts.shift() else ''
      tag.name = parts.shift() or ''
      tag.description = getMultilineDescription()
      exports.parseTagTypes typeString, tag
    when 'define', 'return', 'returns'
      typeString = if matchTypeStr.test(parts[0]) then parts.shift() else ''
      exports.parseTagTypes typeString, tag
      tag.description = getMultilineDescription()
    when 'see'
      if ~str.indexOf('http')
        tag.title = if parts.length &gt; 1 then parts.shift() else ''
        tag.url = parts.join(' ')
      else
        tag.local = parts.join(' ')
    when 'api'
      tag.visibility = parts.shift()
    when 'public', 'private', 'protected'
      tag.visibility = type
    when 'enum', 'typedef', 'type'
      typeString = parts.shift()
      if not /{.*}/.test typeString
        typeString = '{' + typeString + '}'
      exports.parseTagTypes typeString, tag
    when 'lends', 'memberof'
      tag.parent = parts.shift()
    when 'extends', 'implements', 'augments'
      tag.otherClass = parts.shift()
    when 'borrows'
      tag.otherMemberName = parts.join(' ').split(' as ')[0]
      tag.thisMemberName = parts.join(' ').split(' as ')[1]
    when 'throws'
      if /{([^}]+)}\s*(.*)/.exec str
        tag.message = RegExp.$1
        tag.description = RegExp.$2
      else
        tag.message = ''
        tag.description = str
    when 'description'
      tag.full = parts.join(' ').trim()
      tag.summary = tag.full.split('\n\n')[0]
      tag.body = tag.full.split('\n\n').slice(1).join('\n\n')
    else
      tag.string = getMultilineDescription().replace(/\s+$/, '')

  tag

##
# Parse tag type string &quot;{Array|Object}&quot; etc.
# This function also supports complex type descriptors like in jsDoc or even the enhanced syntax used by the
# [google closure compiler](https://developers.google.com/closure/compiler/docs/js-for-compiler#types)
#
# The resulting array from the type descriptor `{number|string|{name:string,age:number|date}}` would look like this:
#
#     [
#       'number',
#       'string',
#       {
#         age: ['number', 'date'],
#         name: ['string']
#       }
#     ]
#
# @param {String} str
# @return {Array}
# @api public
exports.parseTagTypes = (str, tag) -&gt;
  if not str
    if tag
      tag.types = []
      tag.typesDescription = ''
      tag.optional = tag.nullable = tag.nonNullable = tag.variable = false
    return []
  {parse, publish, NodeType} = require 'jsdoctypeparser'
  result = parse str.substr(1, str.length - 2)
  optional = false

  if result.type is NodeType.OPTIONAL
    optional = true
    result = result.value

  transform = (ast) -&gt;
    if ast.type is NodeType.NAME
      [ast.name]
    else if ast.type is NodeType.UNION
      left = transform ast.left
      right = transform ast.right
      [].push.apply left, right
      left
    else if ast.type is NodeType.RECORD
      [ast.entries.reduce (obj, entry) -&gt;
        obj[entry.key] = transform entry.value
        obj
      , {}]
    else
      [publish ast]
  types = transform result

  if tag
    tag.types = types
    #tag.typesDescription = result.toHtml()
    tag.optional = (tag.name and tag.name.slice(0,1) is '[') or optional
    #tag.nullable = result.nullable
    #tag.nonNullable = result.nonNullable
    #tag.variable = result.variable

  types

##
# Determine if a parameter is optional.
#
# Examples:
# JSDoc: {Type} [name]
# Google: {Type=} name
# TypeScript: {Type?} name
#
# @param {Object} tag
# @return {Boolean}
# @api public
exports.parseParamOptional = (tag) -&gt;
  lastTypeChar = tag.types.slice(-1)[0].slice(-1)
  tag.name.slice(0,1) is '[' or lastTypeChar is '=' or lastTypeChar is '?'

##
# Parse the context from the given `str` of js.
#
# This method attempts to discover the context
# for the comment based on it's code. Currently
# supports:
#
#   - classes
#   - class constructors
#   - class methods
#   - function statements
#   - function expressions
#   - prototype methods
#   - prototype properties
#   - methods
#   - properties
#   - declarations
#
# @param {String} str
# @param {Object=} parentContext An indication if we are already in something. Like a namespace or an inline declaration.
# @return {Object}
# @api public
exports.parseCodeContext = (str, parentContext) -&gt;
  if not parentContext
    parentContext = {}
  ctx = undefined
  # loop through all context matchers, returning the first successful match
  exports.contextPatternMatchers.some((matcher) -&gt;
    ctx = matcher(str, parentContext)
  ) and ctx

exports.contextPatternMatchers = [
  # class, possibly exported by name or as a default
  (str) -&gt;
    if /^\s*(export(\s+default)?\s+)?class\s+([\w$]+)(\s+extends\s+([\w$.]+(?:\(.*\))?))?\s*{/.exec(str)
      return {
        type: 'class'
        constructor: RegExp.$3
        cons: RegExp.$3
        name: RegExp.$3
        extends: RegExp.$5
        string: 'new ' + RegExp.$3 + '()'
      }
  # class constructor
  (str, parentContext) -&gt;
    if /^\s*constructor\s*\(/.exec(str)
      return {
        type: 'constructor'
        constructor: parentContext.name
        cons: parentContext.name
        name: 'constructor'
        string: (if parentContext?.name then parentContext.name + '.prototype.' else '') + 'constructor()'
      }
  # class method
  (str, parentContext) -&gt;
    if /^\s*(static)?\s*(\*)?\s*([\w$]+|\[.*\])\s*\(/.exec(str)
      return {
        type: 'method'
        constructor: parentContext.name
        cons: parentContext.name
        name: RegExp.$2 + RegExp.$3
        string: (if parentContext?.name then parentContext.name + (if RegExp.$1 then '.' else '.prototype.') else '') + RegExp.$2 + RegExp.$3 + '()'
      }
  # named function statementpossibly exported by name or as a default
  (str) -&gt;
    if /^\s*(export(\s+default)?\s+)?function\s+([\w$]+)\s*\(/.exec(str)
      return {
        type: 'function'
        name: RegExp.$3
        string: RegExp.$3 + '()'
      }
  # anonymous function expression exported as a default
  (str) -&gt;
    if /^\s*export\s+default\s+function\s*\(/.exec(str)
      return {
        type: 'function'
        name: RegExp.$1 # undefined
        string: RegExp.$1 + '()'
      }
  # function expression
  (str) -&gt;
    if /^return\s+function(?:\s+([\w$]+))?\s*\(/.exec(str)
      return {
        type: 'function'
        name: RegExp.$1
        string: RegExp.$1 + '()'
      }
  # function expression
  (str) -&gt;
    if /^\s*(?:const|let|var)\s+([\w$]+)\s*=\s*function/.exec(str)
      return {
        type: 'function'
        name: RegExp.$1
        string: RegExp.$1 + '()'
      }
  # prototype method
  (str, parentContext) -&gt;
    if /^\s*([\w$.]+)\s*\.\s*prototype\s*\.\s*([\w$]+)\s*=\s*function/.exec(str)
      return {
        type: 'method'
        constructor: RegExp.$1
        cons: RegExp.$1
        name: RegExp.$2
        string: RegExp.$1 + '.prototype.' + RegExp.$2 + '()'
      }
  # prototype property
  (str) -&gt;
    if /^\s*([\w$.]+)\s*\.\s*prototype\s*\.\s*([\w$]+)\s*=\s*([^\n;]+)/.exec(str)
      return {
        type: 'property'
        constructor: RegExp.$1
        cons: RegExp.$1
        name: RegExp.$2
        value: RegExp.$3.trim()
        string: RegExp.$1 + '.prototype.' + RegExp.$2
      }
  # prototype property without assignment
  (str) -&gt;
    if /^\s*([\w$]+)\s*\.\s*prototype\s*\.\s*([\w$]+)\s*/.exec(str)
      return {
        type: 'property'
        constructor: RegExp.$1
        cons: RegExp.$1
        name: RegExp.$2
        string: RegExp.$1 + '.prototype.' + RegExp.$2
      }
  # inline prototype
  (str) -&gt;
    if /^\s*([\w$.]+)\s*\.\s*prototype\s*=\s*{/.exec(str)
      return {
        type: 'prototype'
        constructor: RegExp.$1
        cons: RegExp.$1
        name: RegExp.$1
        string: RegExp.$1 + '.prototype'
      }
  # inline method
  (str, parentContext) -&gt;
    if /^\s*([\w$.]+)\s*:\s*function/.exec(str)
      return {
        type: 'method'
        constructor: parentContext.name
        cons: parentContext.name
        name: RegExp.$1
        string: (if parentContext?.name then parentContext.name + '.prototype.' else '') + RegExp.$1 + '()'
      }
  # inline property
  (str, parentContext) -&gt;
    if /^\s*([\w$.]+)\s*:\s*([^\n;]+)/.exec(str)
      return {
        type: 'property'
        constructor: parentContext.name
        cons: parentContext.name
        name: RegExp.$1
        value: RegExp.$2.trim()
        string: (if parentContext?.name then parentContext.name + '.' else '') + RegExp.$1
      }
  # inline getter/setter
  (str, parentContext) -&gt;
    if /^\s*(get|set)\s*([\w$.]+)\s*\(/.exec(str)
      return {
        type: 'property'
        constructor: parentContext.name
        cons: parentContext.name
        name: RegExp.$2
        string: (if parentContext?.name then parentContext.name + '.prototype.' else '') + RegExp.$2
      }
  # method
  (str) -&gt;
    if /^\s*([\w$.]+)\s*\.\s*([\w$]+)\s*=\s*function/.exec(str)
      return {
        type: 'method'
        receiver: RegExp.$1
        name: RegExp.$2
        string: RegExp.$1 + '.' + RegExp.$2 + '()'
      }
  # property
  (str) -&gt;
    if /^\s*([\w$.]+)\s*\.\s*([\w$]+)\s*=\s*([^\n;]+)/.exec(str)
      return {
        type: 'property'
        receiver: RegExp.$1
        name: RegExp.$2
        value: RegExp.$3.trim()
        string: RegExp.$1 + '.' + RegExp.$2
      }
  # declaration
  (str) -&gt;
    if /^\s*(?:const|let|var)\s+([\w$]+)\s*=\s*([^\n;]+)/.exec(str)
      return {
        type: 'declaration'
        name: RegExp.$1
        value: RegExp.$2.trim()
        string: RegExp.$1
      }
]

exports.setMarkedOptions = (opts) -&gt;
  markdown.setOptions opts</pre></div></div></div><script src="http://code.jquery.com/jquery-1.11.0.min.js"></script><script src="../bootstrap-3.2.0-dist/js/bootstrap.min.js"></script><script src="../google-code-prettify/prettify.js"></script><script src="../script.js"></script><script src="../group-examples.js"></script><a href="https://github.com/croquiscom/crojsdoc"><img class="github-ribbon" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a></body></html>