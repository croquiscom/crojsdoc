// Generated by CoffeeScript 1.7.1
(function() {
  var Collector, basename, collect, dirname, dox, fs, glob, markdown, resolve, walkdir, _ref;

  dox = require('./dox');

  fs = require('fs');

  glob = require('glob');

  markdown = require('marked');

  walkdir = require('walkdir');

  _ref = require('path'), basename = _ref.basename, dirname = _ref.dirname, resolve = _ref.resolve;

  Collector = (function() {
    function Collector(paths, options) {
      this.paths = paths;
      this.options = options;
      this.result = {
        project_title: this.options.title || 'croquis-jsdoc',
        ids: {},
        classes: {},
        guides: [],
        pages: {},
        restapis: {},
        features: [],
        files: []
      };
    }

    Collector.prototype.getComments = function(file, path) {
      var add_to_file, comments, content, feature, namespace;
      if (fs.statSync(file).isDirectory()) {
        return;
      }
      content = fs.readFileSync(file, 'utf-8').trim();
      if (!content) {
        return;
      }
      file = file.substr(path.length + 1);
      if (/\.coffee$/.test(file)) {
        comments = dox.parseCommentsCoffee(content, {
          raw: true
        });
        add_to_file = true;
      } else if (/\.js$/.test(file)) {
        comments = dox.parseComments(content, {
          raw: true
        });
        add_to_file = true;
      } else if (/Page\.md$/.test(file)) {
        namespace = '';
        file = file.substr(0, file.length - 3).replace(/[^A-Za-z0-9]*Page$/, '');
        file = file.replace(/(.*)\//, function(_, $1) {
          namespace = $1;
          return '';
        });
        comments = [
          {
            description: {
              summary: '',
              body: content,
              full: ''
            },
            tags: [
              {
                type: 'page',
                string: file
              }, {
                type: 'namespace',
                string: namespace
              }
            ]
          }
        ];
      } else if (/Guide\.md$/.test(file)) {
        file = file.substr(0, file.length - 8).replace(/\//g, '.');
        this.result.guides.push({
          name: file,
          filename: 'guides/' + file,
          content: content
        });
      } else if (/\.feature$/.test(file)) {
        file = file.substr(0, file.length - 8);
        namespace = '';
        file = file.replace(/(.*)\//, function(_, $1) {
          namespace = $1 + '/';
          return '';
        });
        feature = '';
        content = content.replace(/Feature: (.*)/, function(_, $1) {
          feature = $1;
          return '';
        });
        this.result.features.push({
          name: namespace + file,
          namespace: namespace,
          filename: 'features/' + namespace.replace(/\//g, '.') + file,
          feature: feature,
          content: content
        });
      }
      if (add_to_file) {
        namespace = '';
        file = file.replace(/(.*)\//, function(_, $1) {
          namespace = $1 + '/';
          return '';
        });
        this.result.files.push({
          name: namespace + file,
          namespace: namespace,
          filename: 'files/' + namespace.replace(/\//g, '.') + file,
          content: content
        });
      }
      return comments != null ? comments.filter(function(comment) {
        var _ref1;
        return comment.description.full || comment.description.summary || comment.description.body || ((_ref1 = comment.tags) != null ? _ref1.length : void 0) > 0;
      }) : void 0;
    };

    Collector.prototype.processParamFlags = function(tag) {
      if (/\[([^\[\]]+)\]/.exec(tag.name)) {
        tag.name = RegExp.$1;
        tag.optional = true;
      }
      if (tag.name.substr(0, 1) === '+') {
        tag.name = tag.name.substr(1);
        tag.addable = true;
      }
      if (tag.name.substr(0, 1) === '-') {
        tag.name = tag.name.substr(1);
        tag.excludable = true;
      }
      return tag;
    };

    Collector.prototype.findParam = function(params, name) {
      var found, param, _i, _len;
      for (_i = 0, _len = params.length; _i < _len; _i++) {
        param = params[_i];
        if (param.name === name) {
          return param;
        }
        if (param.params) {
          found = this.findParam(param.params, name);
          if (found) {
            return found;
          }
        }
      }
    };

    Collector.prototype.makeNested = function(comment, targetName) {
      var i, match, param, parentParam, _results;
      i = comment[targetName].length;
      _results = [];
      while (i-- > 0) {
        param = comment[targetName][i];
        if (match = param.name.match(/\[?([^=]*)\.([^\]]*)\]?/)) {
          parentParam = this.findParam(comment[targetName], match[1]);
          if (parentParam) {
            comment[targetName].splice(i, 1);
            parentParam[targetName] = parentParam[targetName] || [];
            param.name = match[2];
            _results.push(parentParam[targetName].unshift(param));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Collector.prototype.applyMarkdown = function(str) {
      str = str.replace(/#\\#/g, '##');
      return markdown(str);
    };

    Collector.prototype.classifyComments = function(file, comments) {
      var current_class, current_module;
      current_class = void 0;
      current_module = void 0;
      return comments.forEach((function(_this) {
        return function(comment) {
          var i, id, last, seperator, tag, _i, _len, _ref1;
          comment.defined_in = file;
          comment.ctx || (comment.ctx = {});
          comment.params = [];
          comment.returnprops = [];
          comment.throws = [];
          comment.resterrors = [];
          comment.sees = [];
          comment.todos = [];
          comment["extends"] = [];
          comment.subclasses = [];
          comment.uses = [];
          comment.usedbys = [];
          comment.properties = [];
          comment.examples = [];
          if (comment.ctx.type === 'property' || comment.ctx.type === 'method') {
            id = comment.ctx.string.replace('()', '');
          } else {
            id = comment.ctx.name;
          }
          comment.ctx.fullname = id;
          comment.namespace = '';
          if (comment.ctx.type === 'property' || comment.ctx.type === 'method') {
            if (comment.ctx.cons != null) {
              comment["static"] = false;
              comment.ctx.class_name = comment.ctx.cons;
            } else if (comment.ctx.receiver != null) {
              comment["static"] = true;
              comment.ctx.class_name = comment.ctx.receiver;
            }
          }
          last = 0;
          _ref1 = comment.tags;
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            tag = _ref1[i];
            if (tag.type === '') {
              comment.tags[last].string += "\n" + tag.string;
              continue;
            }
            last = i;
            switch (tag.type) {
              case 'page':
              case 'restapi':
              case 'class':
                comment.ctx.type = tag.type;
                if (tag.string) {
                  comment.ctx.name = tag.string;
                  comment.ctx.fullname = id = comment.ctx.name;
                }
                break;
              case 'module':
                comment.ctx.type = 'class';
                comment.is_module = true;
                if (tag.string) {
                  comment.ctx.name = tag.string;
                  comment.ctx.fullname = id = comment.ctx.name;
                }
                comment.code = null;
                break;
              case 'memberOf':
                if (/(::|#|prototype)$/.test(tag.parent)) {
                  comment["static"] = false;
                  comment.ctx.class_name = tag.parent.replace(/(::|#|prototype)$/, '');
                } else {
                  comment["static"] = true;
                  comment.ctx.class_name = tag.parent;
                }
                break;
              case 'namespace':
                comment.namespace = tag.string ? tag.string + '.' : '';
                break;
              case 'property':
              case 'method':
                comment.ctx.type = tag.type;
                comment.ctx.name = tag.string;
                break;
              case 'static':
                comment["static"] = true;
                break;
              case 'private':
                comment.isPrivate = true;
                break;
              case 'abstract':
                comment.abstract = true;
                break;
              case 'async':
                comment.async = true;
                break;
              case 'param':
              case 'return':
              case 'returnprop':
              case 'throws':
              case 'resterror':
              case 'see':
              case 'extends':
              case 'todo':
              case 'type':
              case 'api':
              case 'uses':
              case 'override':
                break;
              default:
                console.log("Unknown tag : " + tag.type + " in " + file);
            }
          }
          if (comment.ctx.class_name) {
            if (comment.ctx.type === 'function') {
              comment.ctx.type = 'method';
            } else if (comment.ctx.type === 'declaration') {
              comment.ctx.type = 'property';
            }
            seperator = comment["static"] ? '.' : '::';
            id = comment.ctx.class_name + seperator + comment.ctx.name;
            comment.ctx.fullname = comment.ctx.class_name.replace(/.*[\./](\w+)/, '$1') + seperator + comment.ctx.name;
          }
          if (comment.ctx.type === 'class') {
            current_class = comment;
            if (comment.is_module) {
              current_module = comment;
            }
          }
          if ((comment.ctx.type === 'property' || comment.ctx.type === 'method') && !comment.namespace) {
            if (current_class) {
              comment.namespace = current_class.namespace;
            }
            if (current_module && !comment.ctx.class_name) {
              comment.ctx.class_name = current_module.ctx.name;
            }
          }
          if (id) {
            if (_this.result.ids.hasOwnProperty(id)) {
              _this.result.ids[id] = 'DUPLICATED ENTRY';
            } else {
              _this.result.ids[id] = comment;
              _this.result.ids[comment.namespace + id] = comment;
            }
            comment.html_id = (comment.namespace + id).replace(/[^A-Za-z0-9_]/g, '_');
          }
          switch (comment.ctx.type) {
            case 'class':
              comment.ctx.name = comment.namespace + comment.ctx.name;
              comment.ctx.fullname = comment.namespace + comment.ctx.fullname;
              _this.result.classes[comment.ctx.name] = comment;
              if (comment.is_module) {
                return comment.filename = 'modules/' + comment.ctx.name.replace(/\//g, '.');
              } else {
                return comment.filename = 'classes/' + comment.ctx.name.replace(/\//g, '.');
              }
              break;
            case 'property':
            case 'method':
              comment.ctx.class_name = comment.namespace + comment.ctx.class_name;
              return comment.filename = 'classes/' + comment.ctx.class_name.replace(/\//g, '.');
            case 'page':
              return comment.filename = 'pages';
            case 'restapi':
              return comment.filename = 'restapis';
          }
        };
      })(this));
    };

    Collector.prototype.processComments = function(comments) {
      return comments.forEach((function(_this) {
        return function(comment) {
          var class_comment, class_name, desc, i, str, tag, type, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
          desc = comment.description;
          if (desc) {
            desc.full = _this.applyMarkdown(desc.full);
            desc.summary = _this.applyMarkdown(desc.summary);
            desc.body = _this.applyMarkdown(desc.body);
          }
          _ref1 = comment.tags;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            tag = _ref1[_i];
            switch (tag.type) {
              case 'param':
                tag = _this.processParamFlags(tag);
                _ref2 = tag.types;
                for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
                  type = _ref2[i];
                  tag.types[i] = type;
                }
                tag.description = tag.description;
                comment.params.push(tag);
                break;
              case 'return':
                _ref3 = tag.types;
                for (i = _k = 0, _len2 = _ref3.length; _k < _len2; i = ++_k) {
                  type = _ref3[i];
                  tag.types[i] = type;
                }
                tag.description = tag.description;
                comment["return"] = tag;
                break;
              case 'returnprop':
                tag = dox.parseTag('@param ' + tag.string);
                tag = _this.processParamFlags(tag);
                _ref4 = tag.types;
                for (i = _l = 0, _len3 = _ref4.length; _l < _len3; i = ++_l) {
                  type = _ref4[i];
                  tag.types[i] = type;
                }
                tag.description = tag.description;
                comment.returnprops.push(tag);
                break;
              case 'throws':
                if (/{([^}]+)}\s*(.*)/.exec(tag.string)) {
                  comment.throws.push({
                    message: RegExp.$1,
                    description: RegExp.$2
                  });
                } else {
                  comment.throws.push({
                    message: tag.string,
                    description: ''
                  });
                }
                break;
              case 'resterror':
                if (/{(\d+)\/([A-Za-z0-9_ ]+)}\s*(.*)/.exec(tag.string)) {
                  comment.resterrors.push({
                    code: RegExp.$1,
                    message: RegExp.$2,
                    description: RegExp.$3
                  });
                }
                break;
              case 'see':
                str = tag.local || tag.url;
                comment.sees.push(str);
                break;
              case 'todo':
                comment.todos.push(tag.string);
                break;
              case 'extends':
                comment["extends"].push(tag.string);
                if ((_ref5 = _this.result.ids[tag.string]) != null) {
                  _ref5.subclasses.push(comment.ctx.name);
                }
                break;
              case 'uses':
                comment.uses.push(tag.string);
                if ((_ref6 = _this.result.ids[tag.string]) != null) {
                  _ref6.usedbys.push(comment.ctx.name);
                }
                break;
              case 'type':
                _ref7 = tag.types;
                for (i = _m = 0, _len4 = _ref7.length; _m < _len4; i = ++_m) {
                  type = _ref7[i];
                  tag.types[i] = type;
                }
                comment.types = tag.types;
                break;
              case 'example':
                comment.examples.push(tag);
                break;
              case 'override':
                if (_this.result.ids[tag.string] && _this.result.ids[tag.string] !== 'DUPLICATED ENTRY') {
                  comment.override = _this.result.ids[tag.string];
                }
                comment.override_link = tag.string;
            }
          }
          if (comment.ctx.type === 'class') {
            if (/^class +\w+ +extends +([\w\.]+)/.exec(comment.code)) {
              comment["extends"].push(RegExp.$1);
              if ((_ref8 = _this.result.ids[RegExp.$1]) != null) {
                _ref8.subclasses.push(comment.ctx.name);
              }
            }
          }
          _this.makeNested(comment, 'params');
          _this.makeNested(comment, 'returnprops');
          switch (comment.ctx.type) {
            case 'property':
            case 'method':
              class_name = comment.ctx.class_name;
              if (class_name && (class_comment = _this.result.classes[class_name])) {
                class_comment.properties.push(comment);
                if (class_comment.is_module) {
                  return comment.filename = comment.filename.replace('classes/', 'modules/');
                }
              }
              break;
            case 'page':
              return _this.result.pages[comment.ctx.name] = comment;
            case 'restapi':
              return _this.result.restapis[comment.ctx.name] = comment;
          }
        };
      })(this));
    };

    Collector.prototype.refineResult = function() {
      var result;
      result = this.result;
      result.classes = Object.keys(result.classes).sort(function(a, b) {
        var a_ns, b_ns;
        a_ns = result.classes[a].namespace;
        b_ns = result.classes[b].namespace;
        if (a_ns < b_ns) {
          return -1;
        }
        if (a_ns > b_ns) {
          return 1;
        }
        if (a < b) {
          return -1;
        } else {
          return 1;
        }
      }).map(function(name) {
        return result.classes[name];
      });
      result.pages = Object.keys(result.pages).sort(function(a, b) {
        var a_ns, b_ns;
        a_ns = result.pages[a].namespace;
        b_ns = result.pages[b].namespace;
        if (a_ns < b_ns) {
          return -1;
        }
        if (a_ns > b_ns) {
          return 1;
        }
        if (a < b) {
          return -1;
        } else {
          return 1;
        }
      }).map(function(name) {
        return result.pages[name];
      });
      result.restapis = Object.keys(result.restapis).sort(function(a, b) {
        var a_ns, b_ns;
        a_ns = result.restapis[a].namespace;
        b_ns = result.restapis[b].namespace;
        if (a_ns < b_ns) {
          return -1;
        }
        if (a_ns > b_ns) {
          return 1;
        }
        a = a.replace(/([A-Z]+) \/(.*)/, '-$2 $1');
        b = b.replace(/([A-Z]+) \/(.*)/, '-$2 $1');
        if (a < b) {
          return -1;
        } else {
          return 1;
        }
      }).map(function(name) {
        return result.restapis[name];
      });
      result.guides = result.guides.sort(function(a, b) {
        if (a.name < b.name) {
          return -1;
        } else {
          return 1;
        }
      });
      result.features = result.features.sort(function(a, b) {
        if (a.name < b.name) {
          return -1;
        } else {
          return 1;
        }
      });
      result.files = result.files.sort(function(a, b) {
        var a_ns, b_ns;
        a_ns = a.namespace;
        b_ns = b.namespace;
        if (a_ns < b_ns) {
          return -1;
        }
        if (a_ns > b_ns) {
          return 1;
        }
        if (a.name < b.name) {
          return -1;
        } else {
          return 1;
        }
      });
      result.modules = result.classes.filter(function(klass) {
        return klass.is_module;
      });
      return result.classes = result.classes.filter(function(klass) {
        return !klass.is_module;
      });
    };

    Collector.prototype.run = function() {
      var all_comments, file_count_read;
      file_count_read = 0;
      all_comments = [];
      this.paths.forEach((function(_this) {
        return function(path) {
          var base_path;
          base_path = path = resolve(_this.options.project_dir, path);
          while (/[*?]/.test(basename(base_path))) {
            base_path = dirname(base_path);
          }
          return glob.sync(path).forEach(function(path) {
            var list;
            if (fs.statSync(path).isDirectory()) {
              list = walkdir.sync(path);
            } else {
              list = [path];
            }
            return list.forEach(function(file) {
              var comments;
              comments = _this.getComments(file, base_path);
              if (comments == null) {
                return;
              }
              file_count_read++;
              if (!_this.options.quite) {
                console.log(file + ' is processed');
              }
              file = file.replace(new RegExp("^" + _this.options.project_dir), '');
              _this.classifyComments(file, comments);
              return all_comments.push.apply(all_comments, comments);
            });
          });
        };
      })(this));
      console.log('Total ' + file_count_read + ' files processed');
      this.processComments(all_comments);
      if (!this.options.files) {
        this.result.files = [];
      }
      return this.refineResult();
    };

    return Collector;

  })();

  collect = function(paths, options) {
    var collector;
    collector = new Collector(paths, options);
    collector.run();
    return collector.result;
  };

  module.exports = collect;

}).call(this);
