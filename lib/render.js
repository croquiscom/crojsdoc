// Generated by CoffeeScript 2.3.2
//#
// Renders documentations from result of collector
// @module render
// @see Renderer
var Renderer, dirname, fs, pug, render, resolve;

fs = require('fs.extra');

pug = require('pug');

({resolve, dirname} = require('path'));

//#
// Renders documentations from result of collector
Renderer = class Renderer {
  //#
  // Creates a Renderer instance
  constructor(result1, options1) {
    var theme;
    this.result = result1;
    this.options = options1;
    theme = 'default';
    this.resources_dir = resolve(__dirname, '../themes', theme, 'resources');
    this.templates_dir = resolve(__dirname, '../themes', theme, 'templates');
  }

  //#
  // @param {String} type
  // @return {String}
  _makeMissingLink(type, place = '') {
    var txt;
    txt = this.result.ids[type] ? `'${type}' link is ambiguous` : `'${type}' link does not exist`;
    console.log(txt + ` ${place}`);
    return `<span class='missing-link'>${type}</span>`;
  }

  //#
  // Makes links for given type

  // * "String" -&gt; "&lt;a href='reference url for String'&gt;String&lt;/a&gt;"
  // * "Array&lt;Model&gt;" -&gt; "&lt;a href='reference url for Array'&gt;Array&lt;/a&gt;&amp;lt;&lt;a href='internal url for Model'&gt;Model&lt;/a&gt;&amp;gt;"
  // @param {String} rel_path
  // @param {String} type
  // @return {String}
  _makeTypeLink(rel_path, type, place = '') {
    var getlink, res;
    if (!type) {
      return type;
    }
    getlink = (type) => {
      var filename, html_id, link;
      if (this.options.types[type]) {
        link = this.options.types[type];
      } else if (this.result.ids[type] && this.result.ids[type] !== 'DUPLICATED ENTRY') {
        filename = this.result.ids[type].filename + '.html';
        html_id = this.result.ids[type].html_id || '';
        link = `${rel_path}${filename}#${html_id}`;
      } else {
        return this._makeMissingLink(type, place);
      }
      return `<a href='${link}'>${type}</a>`;
    };
    if (res = type.match(/\[(.*)\]\((.*)\)/)) {
      this.options.types[res[1]] = res[2];
      return `<a href='${res[2]}'>${res[1]}</a>`;
    }
    if (res = type.match(/(.*?)<(.*)>/)) {
      return `${this._makeTypeLink(rel_path, res[1])}&lt;${this._makeTypeLink(rel_path, res[2])}&gt;`;
    } else {
      return getlink(type);
    }
  }

  //#
  // @param {String} rel_path
  // @param {String} str
  // @return {String}
  _makeSeeLink(rel_path, str) {
    var filename, html_id;
    if (this.result.ids[str]) {
      filename = this.result.ids[str].filename + '.html';
      html_id = this.result.ids[str].html_id || '';
      str = `<a href='${rel_path}${filename}#${html_id}'>${str}</a>`;
    }
    return str;
  }

  //#
  // Converts link markups to HTML links in the description
  // @param {String} rel_path
  // @param {String} str
  // @return {String}
  _convertLink(rel_path, str) {
    if (!str) {
      return '';
    }
    str = str.replace(/\[\[#([^\[\]]+)\]\]/g, (_, $1) => {
      var filename, html_id;
      if (this.result.ids[$1] && this.result.ids[$1] !== 'DUPLICATED ENTRY') {
        filename = this.result.ids[$1].filename + '.html';
        html_id = this.result.ids[$1].html_id || '';
        return `<a href='${rel_path}${filename}#${html_id}'>${$1}</a>`;
      } else {
        return this._makeMissingLink($1);
      }
    });
    return str;
  }

  //#
  // @param {String} source
  // @param {String} target
  // @param {Function} callback
  _copyResources(source, target, callback) {
    var file, files, i, len;
    try {
      files = fs.readdirSync(target);
    } catch (error1) {
      files = [];
    }
    for (i = 0, len = files.length; i < len; i++) {
      file = files[i];
      if (file[0] !== '.') {
        fs.rmrfSync(resolve(target, file));
      }
    }
    try {
      fs.mkdirSync(target);
    } catch (error1) {}
    return fs.copyRecursive(source, target, function() {
      return callback();
    });
  }

  //#
  // Renders one template
  _renderOne(pug_options, template, output) {
    pug_options.result = this.result;
    if (!pug_options.makeTypeLink) {
      pug_options.makeTypeLink = this._makeTypeLink.bind(this);
    }
    pug_options.makeSeeLink = this._makeSeeLink.bind(this);
    pug_options.convertLink = this._convertLink.bind(this);
    pug_options.github = this.options.github;
    pug_options.cache = true;
    pug_options.self = true;
    return pug.renderFile(`${this.templates_dir}/${template}.pug`, pug_options, (error, result) => {
      var output_file;
      if (error) {
        return console.error(error.stack);
      }
      output_file = `${this.options.output_dir}/${output}.html`;
      return fs.writeFile(output_file, result, (error) => {
        if (error) {
          return console.error('failed to create ' + output_file);
        }
        if (!this.options.quiet) {
          return console.log(output_file + ' is created');
        }
      });
    });
  }

  //#
  // Renders the README
  _renderReadme() {
    var pug_options;
    pug_options = {
      rel_path: './',
      name: 'README',
      content: this.result.readme,
      type: 'home'
    };
    return this._renderOne(pug_options, 'extra', 'index');
  }

  //#
  // Renders guides
  _renderGuides() {
    if (this.result.guides.length === 0) {
      return;
    }
    try {
      fs.mkdirSync(`${this.options.output_dir}/guides`);
    } catch (error1) {}
    return this.result.guides.forEach((guide) => {
      var pug_options;
      pug_options = {
        rel_path: '../',
        name: guide.name,
        content: guide.content,
        type: 'guides'
      };
      return this._renderOne(pug_options, 'extra', guide.filename);
    });
  }

  //#
  // Renders pages
  _renderPages() {
    var pug_options;
    if (this.result.pages.length > 0) {
      pug_options = {
        rel_path: './',
        name: 'Pages',
        type: 'pages'
      };
      return this._renderOne(pug_options, 'pages', 'pages');
    }
  }

  //#
  // Renders REST apis
  _renderRESTApis() {
    var pug_options;
    if (this.result.restapis.length > 0) {
      pug_options = {
        rel_path: './',
        name: 'REST APIs',
        type: 'restapis'
      };
      return this._renderOne(pug_options, 'restapis', 'restapis');
    }
  }

  //#
  // Renders classes
  _renderClasses() {
    var pug_options;
    if (this.result.classes.length === 0) {
      return;
    }
    try {
      fs.mkdirSync(`${this.options.output_dir}/classes`);
    } catch (error1) {}
    pug_options = {
      rel_path: '../',
      type: 'classes'
    };
    this._renderOne(pug_options, 'class-toc', 'classes/index');
    return this.result.classes.forEach((klass) => {
      pug_options = {
        rel_path: '../',
        name: klass.ctx.name,
        klass: klass,
        properties: klass.properties,
        type: 'classes',
        _makeTypeLink: (path, type) => {
          return this._makeTypeLink(path, type, `(in ${klass.full_path})`);
        }
      };
      return this._renderOne(pug_options, 'class', klass.filename);
    });
  }

  //#
  // Renders modules
  _renderModules() {
    var pug_options;
    if (this.result.modules.length === 0) {
      return;
    }
    try {
      fs.mkdirSync(`${this.options.output_dir}/modules`);
    } catch (error1) {}
    pug_options = {
      rel_path: '../',
      type: 'modules'
    };
    this._renderOne(pug_options, 'module-toc', 'modules/index');
    return this.result.modules.forEach((module) => {
      pug_options = {
        rel_path: '../',
        name: module.ctx.name,
        module_data: module,
        properties: module.properties,
        type: 'modules'
      };
      return this._renderOne(pug_options, 'module', module.filename);
    });
  }

  //#
  // Renders features
  _renderFeatures() {
    if (this.result.features.length === 0) {
      return;
    }
    try {
      fs.mkdirSync(`${this.options.output_dir}/features`);
    } catch (error1) {}
    return this.result.features.forEach((feature) => {
      var pug_options;
      pug_options = {
        rel_path: '../',
        name: feature.name,
        feature: feature,
        type: 'features'
      };
      return this._renderOne(pug_options, 'feature', feature.filename);
    });
  }

  //#
  // Renders files
  _renderFiles() {
    if (this.result.files.length === 0) {
      return;
    }
    try {
      fs.mkdirSync(`${this.options.output_dir}/files`);
    } catch (error1) {}
    return this.result.files.forEach((file) => {
      var pug_options;
      pug_options = {
        rel_path: '../',
        name: file.name,
        file: file,
        type: 'files'
      };
      return this._renderOne(pug_options, 'file', file.filename);
    });
  }

  //#
  // Groups items by namespaces
  _groupByNamespaces(items) {
    var current_group, current_namespace, grouped_items;
    if (items.length === 0) {
      return [];
    }
    current_group = [];
    grouped_items = [current_group];
    current_namespace = items[0].namespace;
    items.forEach(function(item) {
      if (current_namespace !== item.namespace) {
        current_group = [];
        grouped_items.push(current_group);
        current_namespace = item.namespace;
      }
      return current_group.push(item);
    });
    return grouped_items;
  }

  //#
  // Runs
  run() {
    this.result.ns_pages = this._groupByNamespaces(this.result.pages);
    this.result.ns_restapis = this._groupByNamespaces(this.result.restapis);
    this.result.ns_classes = this._groupByNamespaces(this.result.classes);
    this.result.ns_modules = this._groupByNamespaces(this.result.modules);
    this.result.ns_features = this._groupByNamespaces(this.result.features);
    this.result.ns_files = this._groupByNamespaces(this.result.files);
    return this._copyResources(this.resources_dir, this.options.output_dir, () => {
      this._renderReadme();
      this._renderGuides();
      this._renderPages();
      this._renderRESTApis();
      this._renderClasses();
      this._renderModules();
      this._renderFeatures();
      return this._renderFiles();
    });
  }

};

//#
// Renders
// @param {Result} result
// @param {Options} options
// @memberOf render
render = function(result, options) {
  var renderer;
  renderer = new Renderer(result, options);
  return renderer.run();
};

module.exports = render;
