// Generated by CoffeeScript 1.7.1
(function() {
  var applyMarkdown, basename, classifyComments, dirname, dox, findParam, fs, generate, getComments, glob, makeNested, markdown, processComments, processParamFlags, refineResult, resolve, result, walkdir, _ref;

  fs = require('fs');

  _ref = require('path'), basename = _ref.basename, dirname = _ref.dirname, resolve = _ref.resolve;

  glob = require('glob');

  markdown = require('marked');

  walkdir = require('walkdir');

  dox = require('./dox');

  getComments = function(file, path) {
    var add_to_file, comments, content, feature, namespace;
    if (fs.statSync(file).isDirectory()) {
      return;
    }
    content = fs.readFileSync(file, 'utf-8').trim();
    if (!content) {
      return;
    }
    file = file.substr(path.length + 1);
    if (/\.coffee$/.test(file)) {
      comments = dox.parseCommentsCoffee(content, {
        raw: true
      });
      add_to_file = true;
    } else if (/\.js$/.test(file)) {
      comments = dox.parseComments(content, {
        raw: true
      });
      add_to_file = true;
    } else if (/Page\.md$/.test(file)) {
      namespace = '';
      file = file.substr(0, file.length - 3).replace(/[^A-Za-z0-9]*Page$/, '');
      file = file.replace(/(.*)\//, function(_, $1) {
        namespace = $1;
        return '';
      });
      comments = [
        {
          description: {
            summary: '',
            body: content,
            full: ''
          },
          tags: [
            {
              type: 'page',
              string: file
            }, {
              type: 'namespace',
              string: namespace
            }
          ]
        }
      ];
    } else if (/Guide\.md$/.test(file)) {
      file = file.substr(0, file.length - 8).replace(/\//g, '.');
      result.guides.push({
        name: file,
        filename: 'guides/' + file,
        content: content
      });
    } else if (/\.feature$/.test(file)) {
      file = file.substr(0, file.length - 8);
      namespace = '';
      file = file.replace(/(.*)\//, function(_, $1) {
        namespace = $1 + '/';
        return '';
      });
      feature = '';
      content = content.replace(/Feature: (.*)/, function(_, $1) {
        feature = $1;
        return '';
      });
      result.features.push({
        name: namespace + file,
        namespace: namespace,
        filename: 'features/' + namespace.replace(/\//g, '.') + file,
        feature: feature,
        content: content
      });
    }
    if (add_to_file) {
      namespace = '';
      file = file.replace(/(.*)\//, function(_, $1) {
        namespace = $1 + '/';
        return '';
      });
      result.files.push({
        name: namespace + file,
        namespace: namespace,
        filename: 'files/' + namespace.replace(/\//g, '.') + file,
        content: content
      });
    }
    return comments != null ? comments.filter(function(comment) {
      var _ref1;
      return comment.description.full || comment.description.summary || comment.description.body || ((_ref1 = comment.tags) != null ? _ref1.length : void 0) > 0;
    }) : void 0;
  };

  result = {
    project_title: '',
    ids: {},
    classes: {},
    guides: [],
    pages: {},
    restapis: {},
    features: [],
    files: []
  };

  processParamFlags = function(tag) {
    if (/\[([^\[\]]+)\]/.exec(tag.name)) {
      tag.name = RegExp.$1;
      tag.optional = true;
    }
    if (tag.name.substr(0, 1) === '+') {
      tag.name = tag.name.substr(1);
      tag.addable = true;
    }
    if (tag.name.substr(0, 1) === '-') {
      tag.name = tag.name.substr(1);
      tag.excludable = true;
    }
    return tag;
  };

  findParam = function(params, name) {
    var found, param, _i, _len;
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      param = params[_i];
      if (param.name === name) {
        return param;
      }
      if (param.params) {
        found = findParam(param.params, name);
        if (found) {
          return found;
        }
      }
    }
  };

  makeNested = function(comment, targetName) {
    var i, match, param, parentParam, _results;
    i = comment[targetName].length;
    _results = [];
    while (i-- > 0) {
      param = comment[targetName][i];
      if (match = param.name.match(/\[?([^=]*)\.([^\]]*)\]?/)) {
        parentParam = findParam(comment[targetName], match[1]);
        if (parentParam) {
          comment[targetName].splice(i, 1);
          parentParam[targetName] = parentParam[targetName] || [];
          param.name = match[2];
          _results.push(parentParam[targetName].unshift(param));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  applyMarkdown = function(str) {
    str = str.replace(/#\\#/g, '##');
    return markdown(str);
  };

  classifyComments = function(file, comments) {
    var current_class, current_module;
    current_class = void 0;
    current_module = void 0;
    return comments.forEach(function(comment) {
      var i, id, last, seperator, tag, _i, _len, _ref1;
      comment.defined_in = file;
      comment.ctx || (comment.ctx = {});
      comment.params = [];
      comment.returnprops = [];
      comment.throws = [];
      comment.resterrors = [];
      comment.sees = [];
      comment.todos = [];
      comment["extends"] = [];
      comment.subclasses = [];
      comment.uses = [];
      comment.usedbys = [];
      comment.properties = [];
      comment.examples = [];
      if (comment.ctx.type === 'property' || comment.ctx.type === 'method') {
        id = comment.ctx.string.replace('()', '');
      } else {
        id = comment.ctx.name;
      }
      comment.ctx.fullname = id;
      comment.namespace = '';
      if (comment.ctx.type === 'property' || comment.ctx.type === 'method') {
        if (comment.ctx.cons != null) {
          comment["static"] = false;
          comment.ctx.class_name = comment.ctx.cons;
        } else if (comment.ctx.receiver != null) {
          comment["static"] = true;
          comment.ctx.class_name = comment.ctx.receiver;
        }
      }
      last = 0;
      _ref1 = comment.tags;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        tag = _ref1[i];
        if (tag.type === '') {
          comment.tags[last].string += "\n" + tag.string;
          continue;
        }
        last = i;
        switch (tag.type) {
          case 'page':
          case 'restapi':
          case 'class':
            comment.ctx.type = tag.type;
            if (tag.string) {
              comment.ctx.name = tag.string;
              comment.ctx.fullname = id = comment.ctx.name;
            }
            break;
          case 'module':
            comment.ctx.type = 'class';
            comment.is_module = true;
            if (tag.string) {
              comment.ctx.name = tag.string;
              comment.ctx.fullname = id = comment.ctx.name;
            }
            comment.code = null;
            break;
          case 'memberOf':
            if (/(::|#|prototype)$/.test(tag.parent)) {
              comment["static"] = false;
              comment.ctx.class_name = tag.parent.replace(/(::|#|prototype)$/, '');
            } else {
              comment["static"] = true;
              comment.ctx.class_name = tag.parent;
            }
            break;
          case 'namespace':
            comment.namespace = tag.string ? tag.string + '.' : '';
            break;
          case 'property':
          case 'method':
            comment.ctx.type = tag.type;
            comment.ctx.name = tag.string;
            break;
          case 'static':
            comment["static"] = true;
            break;
          case 'private':
            comment.isPrivate = true;
            break;
          case 'abstract':
            comment.abstract = true;
            break;
          case 'async':
            comment.async = true;
            break;
          case 'param':
          case 'return':
          case 'returnprop':
          case 'throws':
          case 'resterror':
          case 'see':
          case 'extends':
          case 'todo':
          case 'type':
          case 'api':
          case 'uses':
          case 'override':
            break;
          default:
            console.log("Unknown tag : " + tag.type + " in " + file);
        }
      }
      if (comment.ctx.class_name) {
        if (comment.ctx.type === 'function') {
          comment.ctx.type = 'method';
        } else if (comment.ctx.type === 'declaration') {
          comment.ctx.type = 'property';
        }
        seperator = comment["static"] ? '.' : '::';
        id = comment.ctx.class_name + seperator + comment.ctx.name;
        comment.ctx.fullname = comment.ctx.class_name.replace(/.*[\./](\w+)/, '$1') + seperator + comment.ctx.name;
      }
      if (comment.ctx.type === 'class') {
        current_class = comment;
        if (comment.is_module) {
          current_module = comment;
        }
      }
      if ((comment.ctx.type === 'property' || comment.ctx.type === 'method') && !comment.namespace) {
        if (current_class) {
          comment.namespace = current_class.namespace;
        }
        if (current_module && !comment.ctx.class_name) {
          comment.ctx.class_name = current_module.ctx.name;
        }
      }
      if (id) {
        if (result.ids.hasOwnProperty(id)) {
          result.ids[id] = 'DUPLICATED ENTRY';
        } else {
          result.ids[id] = comment;
          result.ids[comment.namespace + id] = comment;
        }
        comment.html_id = (comment.namespace + id).replace(/[^A-Za-z0-9_]/g, '_');
      }
      switch (comment.ctx.type) {
        case 'class':
          comment.ctx.name = comment.namespace + comment.ctx.name;
          comment.ctx.fullname = comment.namespace + comment.ctx.fullname;
          result.classes[comment.ctx.name] = comment;
          if (comment.is_module) {
            return comment.filename = 'modules/' + comment.ctx.name.replace(/\//g, '.');
          } else {
            return comment.filename = 'classes/' + comment.ctx.name.replace(/\//g, '.');
          }
          break;
        case 'property':
        case 'method':
          comment.ctx.class_name = comment.namespace + comment.ctx.class_name;
          return comment.filename = 'classes/' + comment.ctx.class_name.replace(/\//g, '.');
        case 'page':
          return comment.filename = 'pages';
        case 'restapi':
          return comment.filename = 'restapis';
      }
    });
  };

  processComments = function(comments) {
    return comments.forEach(function(comment) {
      var class_comment, class_name, desc, i, str, tag, type, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      desc = comment.description;
      if (desc) {
        desc.full = applyMarkdown(desc.full);
        desc.summary = applyMarkdown(desc.summary);
        desc.body = applyMarkdown(desc.body);
      }
      _ref1 = comment.tags;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tag = _ref1[_i];
        switch (tag.type) {
          case 'param':
            tag = processParamFlags(tag);
            _ref2 = tag.types;
            for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
              type = _ref2[i];
              tag.types[i] = type;
            }
            tag.description = tag.description;
            comment.params.push(tag);
            break;
          case 'return':
            _ref3 = tag.types;
            for (i = _k = 0, _len2 = _ref3.length; _k < _len2; i = ++_k) {
              type = _ref3[i];
              tag.types[i] = type;
            }
            tag.description = tag.description;
            comment["return"] = tag;
            break;
          case 'returnprop':
            tag = dox.parseTag('@param ' + tag.string);
            tag = processParamFlags(tag);
            _ref4 = tag.types;
            for (i = _l = 0, _len3 = _ref4.length; _l < _len3; i = ++_l) {
              type = _ref4[i];
              tag.types[i] = type;
            }
            tag.description = tag.description;
            comment.returnprops.push(tag);
            break;
          case 'throws':
            if (/{([^}]+)}\s*(.*)/.exec(tag.string)) {
              comment.throws.push({
                message: RegExp.$1,
                description: RegExp.$2
              });
            } else {
              comment.throws.push({
                message: tag.string,
                description: ''
              });
            }
            break;
          case 'resterror':
            if (/{(\d+)\/([A-Za-z0-9_ ]+)}\s*(.*)/.exec(tag.string)) {
              comment.resterrors.push({
                code: RegExp.$1,
                message: RegExp.$2,
                description: RegExp.$3
              });
            }
            break;
          case 'see':
            str = tag.local || tag.url;
            comment.sees.push(str);
            break;
          case 'todo':
            comment.todos.push(tag.string);
            break;
          case 'extends':
            comment["extends"].push(tag.string);
            if ((_ref5 = result.ids[tag.string]) != null) {
              _ref5.subclasses.push(comment.ctx.name);
            }
            break;
          case 'uses':
            comment.uses.push(tag.string);
            if ((_ref6 = result.ids[tag.string]) != null) {
              _ref6.usedbys.push(comment.ctx.name);
            }
            break;
          case 'type':
            _ref7 = tag.types;
            for (i = _m = 0, _len4 = _ref7.length; _m < _len4; i = ++_m) {
              type = _ref7[i];
              tag.types[i] = type;
            }
            comment.types = tag.types;
            break;
          case 'example':
            comment.examples.push(tag);
            break;
          case 'override':
            if (result.ids[tag.string] && result.ids[tag.string] !== 'DUPLICATED ENTRY') {
              comment.override = result.ids[tag.string];
            }
            comment.override_link = tag.string;
        }
      }
      if (comment.ctx.type === 'class') {
        if (/^class +\w+ +extends +([\w\.]+)/.exec(comment.code)) {
          comment["extends"].push(RegExp.$1);
          if ((_ref8 = result.ids[RegExp.$1]) != null) {
            _ref8.subclasses.push(comment.ctx.name);
          }
        }
      }
      makeNested(comment, 'params');
      makeNested(comment, 'returnprops');
      switch (comment.ctx.type) {
        case 'property':
        case 'method':
          class_name = comment.ctx.class_name;
          if (class_name && (class_comment = result.classes[class_name])) {
            class_comment.properties.push(comment);
            if (class_comment.is_module) {
              return comment.filename = comment.filename.replace('classes/', 'modules/');
            }
          }
          break;
        case 'page':
          return result.pages[comment.ctx.name] = comment;
        case 'restapi':
          return result.restapis[comment.ctx.name] = comment;
      }
    });
  };

  refineResult = function(result) {
    result.classes = Object.keys(result.classes).sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = result.classes[a].namespace;
      b_ns = result.classes[b].namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      if (a < b) {
        return -1;
      } else {
        return 1;
      }
    }).map(function(name) {
      return result.classes[name];
    });
    result.pages = Object.keys(result.pages).sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = result.pages[a].namespace;
      b_ns = result.pages[b].namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      if (a < b) {
        return -1;
      } else {
        return 1;
      }
    }).map(function(name) {
      return result.pages[name];
    });
    result.restapis = Object.keys(result.restapis).sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = result.restapis[a].namespace;
      b_ns = result.restapis[b].namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      a = a.replace(/([A-Z]+) \/(.*)/, '-$2 $1');
      b = b.replace(/([A-Z]+) \/(.*)/, '-$2 $1');
      if (a < b) {
        return -1;
      } else {
        return 1;
      }
    }).map(function(name) {
      return result.restapis[name];
    });
    result.guides = result.guides.sort(function(a, b) {
      if (a.name < b.name) {
        return -1;
      } else {
        return 1;
      }
    });
    result.features = result.features.sort(function(a, b) {
      if (a.name < b.name) {
        return -1;
      } else {
        return 1;
      }
    });
    result.files = result.files.sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = a.namespace;
      b_ns = b.namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      } else {
        return 1;
      }
    });
    result.modules = result.classes.filter(function(klass) {
      return klass.is_module;
    });
    return result.classes = result.classes.filter(function(klass) {
      return !klass.is_module;
    });
  };

  generate = function(paths, genopts) {
    var all_comments, file_count_read;
    result.project_title = genopts.title || 'croquis-jsdoc';
    file_count_read = 0;
    all_comments = [];
    paths.forEach(function(path) {
      var base_path;
      base_path = path = resolve(genopts.project_dir, path);
      while (/[*?]/.test(basename(base_path))) {
        base_path = dirname(base_path);
      }
      return glob.sync(path).forEach(function(path) {
        var list;
        if (fs.statSync(path).isDirectory()) {
          list = walkdir.sync(path);
        } else {
          list = [path];
        }
        return list.forEach(function(file) {
          var comments;
          comments = getComments(file, base_path);
          if (comments == null) {
            return;
          }
          file_count_read++;
          if (!genopts.quite) {
            console.log(file + ' is processed');
          }
          file = file.replace(new RegExp("^" + genopts.project_dir), '');
          classifyComments(file, comments);
          return all_comments.push.apply(all_comments, comments);
        });
      });
    });
    console.log('Total ' + file_count_read + ' files processed');
    processComments(all_comments);
    if (!genopts.files) {
      result.files = [];
    }
    refineResult(result);
    return require('./render')(result, genopts);
  };

  module.exports = generate;

}).call(this);
