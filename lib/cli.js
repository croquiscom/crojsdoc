// Generated by CoffeeScript 1.7.1
(function() {
  var basename, contents, dirname, fs, getOptionsAndPaths, glob, join, options, parseArguments, paths, readConfig, readExternalTypes, readFiles, resolve, result, walkdir, _ref, _ref1;

  fs = require('fs');

  glob = require('glob');

  walkdir = require('walkdir');

  _ref = require('path'), basename = _ref.basename, dirname = _ref.dirname, join = _ref.join, resolve = _ref.resolve;

  readConfig = function(options, paths) {
    var config, safeLoad;
    safeLoad = require('js-yaml').safeLoad;
    try {
      config = safeLoad(fs.readFileSync(join(process.cwd(), 'crojsdoc.yaml'), 'utf-8'));
      if (config.hasOwnProperty('output')) {
        options.output = config.output;
      }
      if (config.hasOwnProperty('title')) {
        options.title = config.title;
      }
      if (config.hasOwnProperty('quite')) {
        options.quite = config.quite === true;
      }
      if (config.hasOwnProperty('files')) {
        options.files = config.files === true;
      }
      if (config.hasOwnProperty('readme') && typeof config.readme === 'string') {
        options.readme = config.readme;
      }
      if (config.hasOwnProperty('external-types')) {
        options['external-types'] = config['external-types'];
      }
      if (config.hasOwnProperty('sources')) {
        if (Array.isArray(config.sources)) {
          [].push.apply(paths, config.sources);
        } else {
          paths.push(config.sources);
        }
      }
      if (config.hasOwnProperty('github')) {
        options.github = config.github;
        if (options.github.branch === void 0) {
          return options.github.branch = 'master';
        }
      }
    } catch (_error) {}
  };

  parseArguments = function(options, paths) {
    var OptionParser, parser, switches;
    OptionParser = require('optparse').OptionParser;
    switches = [['-o', '--output DIRECTORY', 'Output directory'], ['-t', '--title TITLE', 'Document Title'], ['-q', '--quite', 'less output'], ['-r', '--readme DIRECTORY', 'README.md directory path'], ['-f', '--files', 'included source files'], ['--external-types JSONFILE', 'external type definitions']];
    parser = new OptionParser(switches);
    parser.on('*', function(opt, value) {
      if (value === void 0) {
        value = true;
      }
      return options[opt] = value;
    });
    return [].push.apply(paths, parser.parse(process.argv.slice(2)));
  };

  readExternalTypes = function(external_types, types) {
    var content, e, type, url, _results;
    if (!external_types) {
      return;
    }
    if (typeof external_types === 'string') {
      try {
        content = fs.readFileSync(external_types, 'utf-8').trim();
        try {
          external_types = JSON.parse(content);
        } catch (_error) {
          e = _error;
          console.log("external-types: Invalid JSON file");
        }
      } catch (_error) {
        e = _error;
        console.log("external-types: Cannot open " + external_types);
      }
    }
    if (typeof external_types === 'object') {
      _results = [];
      for (type in external_types) {
        url = external_types[type];
        _results.push(types[type] = url);
      }
      return _results;
    }
  };

  getOptionsAndPaths = function() {
    var options, paths;
    options = {
      project_dir: process.cwd(),
      types: {
        Object: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object',
        Boolean: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Boolean',
        String: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String',
        Array: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array',
        Number: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number',
        Date: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date',
        Function: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function',
        RegExp: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/RegExp',
        Error: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error',
        undefined: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/undefined'
      }
    };
    paths = [];
    readConfig(options, paths);
    parseArguments(options, paths);
    readExternalTypes(options['external-types'], options.types);
    options.output_dir = resolve(options.project_dir, options.output || 'doc');
    return [options, paths];
  };

  readFiles = function(paths, options) {
    var base_path, contents, data, path, project_dir_re, _i, _len;
    project_dir_re = new RegExp("^" + options.project_dir);
    contents = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      path = paths[_i];
      base_path = path = resolve(options.project_dir, path);
      while (/[*?]/.test(basename(base_path))) {
        base_path = dirname(base_path);
      }
      glob.sync(path).forEach((function(_this) {
        return function(path) {
          var data, file, list, _j, _len1, _results;
          if (fs.statSync(path).isDirectory()) {
            list = walkdir.sync(path);
          } else {
            list = [path];
          }
          _results = [];
          for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
            file = list[_j];
            if (fs.statSync(file).isDirectory()) {
              continue;
            }
            data = fs.readFileSync(file, 'utf-8').trim();
            if (!data) {
              continue;
            }
            _results.push(contents.push({
              path: file.replace(project_dir_re, ''),
              file: file.substr(path.length + 1),
              data: data
            }));
          }
          return _results;
        };
      })(this));
    }
    try {
      data = fs.readFileSync("" + (options.readme || options.project_dir) + "/README.md", 'utf-8');
      contents.push({
        path: '',
        file: 'README',
        data: data
      });
    } catch (_error) {}
    return contents;
  };

  _ref1 = getOptionsAndPaths(), options = _ref1[0], paths = _ref1[1];

  contents = readFiles(paths, options);

  result = require('./collect')(contents, options);

  require('./render')(result, options);

}).call(this);
