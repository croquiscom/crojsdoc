// Generated by CoffeeScript 1.7.1
(function() {
  var fs, getOptionsAndPaths, options, parseArguments, path, paths, readConfig, readExternalTypes, result, _ref;

  fs = require('fs');

  path = require('path');

  readConfig = function(options, paths) {
    var config, safeLoad;
    safeLoad = require('js-yaml').safeLoad;
    try {
      config = safeLoad(fs.readFileSync(path.join(process.cwd(), 'crojsdoc.yaml'), 'utf-8'));
      if (config.hasOwnProperty('output')) {
        options.output = config.output;
      }
      if (config.hasOwnProperty('title')) {
        options.title = config.title;
      }
      if (config.hasOwnProperty('quite')) {
        options.quite = config.quite === true;
      }
      if (config.hasOwnProperty('files')) {
        options.files = config.files === true;
      }
      if (config.hasOwnProperty('readme') && typeof config.readme === 'string') {
        options.readme = config.readme;
      }
      if (config.hasOwnProperty('external-types')) {
        options['external-types'] = config['external-types'];
      }
      if (config.hasOwnProperty('sources')) {
        if (Array.isArray(config.sources)) {
          [].push.apply(paths, config.sources);
        } else {
          paths.push(config.sources);
        }
      }
      if (config.hasOwnProperty('github')) {
        options.github = config.github;
        if (options.github.branch === void 0) {
          return options.github.branch = 'master';
        }
      }
    } catch (_error) {}
  };

  parseArguments = function(options, paths) {
    var OptionParser, parser, switches;
    OptionParser = require('optparse').OptionParser;
    switches = [['-o', '--output DIRECTORY', 'Output directory'], ['-t', '--title TITLE', 'Document Title'], ['-q', '--quite', 'less output'], ['-r', '--readme DIRECTORY', 'README.md directory path'], ['-f', '--files', 'included source files'], ['--external-types JSONFILE', 'external type definitions']];
    parser = new OptionParser(switches);
    parser.on('*', function(opt, value) {
      if (value === void 0) {
        value = true;
      }
      return options[opt] = value;
    });
    return [].push.apply(paths, parser.parse(process.argv.slice(2)));
  };

  readExternalTypes = function(external_types, types) {
    var content, e, type, url, _results;
    if (!external_types) {
      return;
    }
    if (typeof external_types === 'string') {
      try {
        content = fs.readFileSync(external_types, 'utf-8').trim();
        try {
          external_types = JSON.parse(content);
        } catch (_error) {
          e = _error;
          console.log("external-types: Invalid JSON file");
        }
      } catch (_error) {
        e = _error;
        console.log("external-types: Cannot open " + external_types);
      }
    }
    if (typeof external_types === 'object') {
      _results = [];
      for (type in external_types) {
        url = external_types[type];
        _results.push(types[type] = url);
      }
      return _results;
    }
  };

  getOptionsAndPaths = function() {
    var options, paths;
    options = {
      project_dir: process.cwd(),
      types: {
        Object: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object',
        Boolean: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Boolean',
        String: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String',
        Array: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array',
        Number: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number',
        Date: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date',
        Function: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function',
        RegExp: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/RegExp',
        Error: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error',
        undefined: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/undefined'
      }
    };
    paths = [];
    readConfig(options, paths);
    parseArguments(options, paths);
    readExternalTypes(options['external-types'], options.types);
    options.output_dir = path.resolve(options.project_dir, options.output || 'doc');
    return [options, paths];
  };

  _ref = getOptionsAndPaths(), options = _ref[0], paths = _ref[1];

  result = require('./collect')(paths, options);

  require('./render')(result, options);

}).call(this);
