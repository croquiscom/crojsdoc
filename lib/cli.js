// Generated by CoffeeScript 1.8.0
(function() {
  var basename, dirname, fs, glob, isWindows, join, resolve, walkdir, _buildOptions, _parseArguments, _readConfig, _readExternalTypes, _readSourceFiles, _ref;

  fs = require('fs');

  glob = require('glob');

  walkdir = require('walkdir');

  _ref = require('path'), basename = _ref.basename, dirname = _ref.dirname, join = _ref.join, resolve = _ref.resolve;

  isWindows = process.platform === 'win32';

  _readConfig = function(options) {
    var config, safeLoad;
    safeLoad = require('js-yaml').safeLoad;
    try {
      config = safeLoad(fs.readFileSync(join(process.cwd(), 'crojsdoc.yaml'), 'utf-8'));
      if (config.hasOwnProperty('output')) {
        options.output = config.output;
      }
      if (config.hasOwnProperty('title')) {
        options.title = config.title;
      }
      if (config.hasOwnProperty('quite')) {
        options.quite = config.quite === true;
      }
      if (config.hasOwnProperty('files')) {
        options.files = config.files === true;
      }
      if (config.hasOwnProperty('readme') && typeof config.readme === 'string') {
        options._readme = config.readme;
      }
      if (config.hasOwnProperty('external-types')) {
        options['external-types'] = config['external-types'];
      }
      if (config.hasOwnProperty('sources')) {
        if (Array.isArray(config.sources)) {
          [].push.apply(options._sources, config.sources);
        } else {
          options._sources.push(config.sources);
        }
      }
      if (config.hasOwnProperty('github')) {
        options.github = config.github;
        if (options.github.branch === void 0) {
          options.github.branch = 'master';
        }
      }
      if (config.hasOwnProperty('reverse_see_also')) {
        options.reverse_see_also = config.reverse_see_also === true;
      }
    } catch (_error) {}
  };

  _parseArguments = function(options) {
    var OptionParser, parser, switches;
    OptionParser = require('optparse').OptionParser;
    switches = [['-o', '--output DIRECTORY', 'Output directory'], ['-t', '--title TITLE', 'Document Title'], ['-q', '--quite', 'less output'], ['-r', '--readme DIRECTORY', 'README.md directory path'], ['-f', '--files', 'included source files'], ['--external-types JSONFILE', 'external type definitions']];
    parser = new OptionParser(switches);
    parser.on('*', function(opt, value) {
      if (value === void 0) {
        value = true;
      }
      return options[opt] = value;
    });
    return [].push.apply(options._sources, parser.parse(process.argv.slice(2)));
  };

  _readExternalTypes = function(external_types, types) {
    var content, e, type, url, _results;
    if (!external_types) {
      return;
    }
    if (typeof external_types === 'string') {
      try {
        content = fs.readFileSync(external_types, 'utf-8').trim();
        try {
          external_types = JSON.parse(content);
        } catch (_error) {
          e = _error;
          console.log("external-types: Invalid JSON file");
        }
      } catch (_error) {
        e = _error;
        console.log("external-types: Cannot open " + external_types);
      }
    }
    if (typeof external_types === 'object') {
      _results = [];
      for (type in external_types) {
        url = external_types[type];
        _results.push(types[type] = url);
      }
      return _results;
    }
  };

  _buildOptions = function() {
    var options;
    options = {
      _project_dir: process.cwd(),
      types: {
        Object: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object',
        Boolean: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Boolean',
        String: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String',
        Array: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array',
        Number: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number',
        Date: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date',
        Function: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function',
        RegExp: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/RegExp',
        Error: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error',
        undefined: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/undefined'
      },
      _sources: []
    };
    _readConfig(options);
    _parseArguments(options);
    _readExternalTypes(options['external-types'], options.types);
    options.output_dir = resolve(options._project_dir, options.output || 'doc');
    return options;
  };

  _readSourceFiles = function(options) {
    var base_path, contents, data, path, project_dir_re, _i, _len, _ref1;
    if (isWindows) {
      project_dir_re = new RegExp("^" + options._project_dir.replace(/\\/g, '\\\\'));
    } else {
      project_dir_re = new RegExp("^" + options._project_dir);
    }
    contents = [];
    _ref1 = options._sources;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      path = _ref1[_i];
      base_path = path = resolve(options._project_dir, path);
      while (/[*?]/.test(basename(base_path))) {
        base_path = dirname(base_path);
      }
      glob.sync(path).forEach((function(_this) {
        return function(path) {
          var data, file, list, _j, _len1;
          if (fs.statSync(path).isDirectory()) {
            list = walkdir.sync(path);
          } else {
            list = [path];
          }
          for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
            file = list[_j];
            if (fs.statSync(file).isDirectory()) {
              continue;
            }
            data = fs.readFileSync(file, 'utf-8').trim();
            if (!data) {
              continue;
            }
            if (isWindows) {
              contents.push({
                path: file.replace(project_dir_re, '').replace(/\\/g, '/'),
                file: file.substr(base_path.length + 1).replace(/\\/g, '/'),
                data: data
              });
            } else {
              contents.push({
                path: file.replace(project_dir_re, ''),
                file: file.substr(base_path.length + 1),
                data: data
              });
            }
          }
        };
      })(this));
    }
    try {
      data = fs.readFileSync("" + (options._readme || options._project_dir) + "/README.md", 'utf-8');
      contents.push({
        path: '',
        file: 'README',
        data: data
      });
    } catch (_error) {}
    return contents;
  };

  exports.run = function() {
    var contents, options, result;
    options = _buildOptions();
    contents = _readSourceFiles(options);
    result = require('./collect')(contents, options);
    return require('./render')(result, options);
  };

}).call(this);
