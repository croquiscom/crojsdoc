// Generated by CoffeeScript 1.7.1
(function() {
  var applyMarkdown, basename, classifyComments, convertLink, copyResources, dirname, dox, findParam, fs, generate, getComments, glob, jade, makeMissingLink, makeNested, makeSeeLink, makeTypeLink, markdown, processComments, processParamFlags, refineResult, render, renderClasses, renderFeatures, renderFiles, renderGuides, renderModules, renderPages, renderRESTApis, renderReadme, resolve, result, types, walkdir, _ref;

  fs = require('fs');

  _ref = require('path'), basename = _ref.basename, dirname = _ref.dirname, resolve = _ref.resolve;

  glob = require('glob');

  jade = require('jade');

  markdown = require('marked');

  walkdir = require('walkdir');

  dox = require('./dox');

  types = {
    Object: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object',
    Boolean: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Boolean',
    String: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String',
    Array: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array',
    Number: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number',
    Date: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date',
    Function: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function',
    RegExp: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/RegExp',
    Error: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error',
    undefined: 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/undefined'
  };

  makeMissingLink = function(type, place) {
    var txt;
    if (place == null) {
      place = '';
    }
    txt = result.ids[type] ? "'" + type + "' link is ambiguous" : "'" + type + "' link does not exist";
    console.log(txt + (" " + place));
    return "<span class='missing-link'>" + type + "</span>";
  };

  makeTypeLink = function(rel_path, type, place) {
    var getlink, res;
    if (place == null) {
      place = '';
    }
    if (!type) {
      return type;
    }
    getlink = function(type) {
      var filename, html_id, link;
      if (types[type]) {
        link = types[type];
      } else if (result.ids[type] && result.ids[type] !== 'DUPLICATED ENTRY') {
        filename = result.ids[type].filename + '.html';
        html_id = result.ids[type].html_id;
        link = "" + rel_path + filename + "#" + html_id;
      } else {
        return makeMissingLink(type, place);
      }
      return "<a href='" + link + "'>" + type + "</a>";
    };
    if (res = type.match(/\[(.*)\]\((.*)\)/)) {
      types[res[1]] = res[2];
      return "<a href='" + res[2] + "'>" + res[1] + "</a>";
    }
    if (res = type.match(/(.*?)<(.*)>/)) {
      return "" + (makeTypeLink(rel_path, res[1])) + "&lt;" + (makeTypeLink(rel_path, res[2])) + "&gt;";
    } else {
      return getlink(type);
    }
  };

  makeSeeLink = function(rel_path, str) {
    var filename, html_id;
    if (result.ids[str]) {
      filename = result.ids[str].filename + '.html';
      html_id = result.ids[str].html_id;
      str = "<a href='" + rel_path + filename + "#" + html_id + "'>" + str + "</a>";
    }
    return str;
  };

  getComments = function(file, path) {
    var add_to_file, comments, content, feature, namespace;
    if (fs.statSync(file).isDirectory()) {
      return;
    }
    content = fs.readFileSync(file, 'utf-8').trim();
    if (!content) {
      return;
    }
    file = file.substr(path.length + 1);
    if (/\.coffee$/.test(file)) {
      comments = dox.parseCommentsCoffee(content, {
        raw: true
      });
      add_to_file = true;
    } else if (/\.js$/.test(file)) {
      comments = dox.parseComments(content, {
        raw: true
      });
      add_to_file = true;
    } else if (/Page\.md$/.test(file)) {
      namespace = '';
      file = file.substr(0, file.length - 3).replace(/[^A-Za-z0-9]*Page$/, '');
      file = file.replace(/(.*)\//, function(_, $1) {
        namespace = $1;
        return '';
      });
      comments = [
        {
          description: {
            summary: '',
            body: content,
            full: ''
          },
          tags: [
            {
              type: 'page',
              string: file
            }, {
              type: 'namespace',
              string: namespace
            }
          ]
        }
      ];
    } else if (/Guide\.md$/.test(file)) {
      file = file.substr(0, file.length - 8).replace(/\//g, '.');
      result.guides.push({
        name: file,
        filename: 'guides/' + file,
        content: content
      });
    } else if (/\.feature$/.test(file)) {
      file = file.substr(0, file.length - 8);
      namespace = '';
      file = file.replace(/(.*)\//, function(_, $1) {
        namespace = $1 + '/';
        return '';
      });
      feature = '';
      content = content.replace(/Feature: (.*)/, function(_, $1) {
        feature = $1;
        return '';
      });
      result.features.push({
        name: namespace + file,
        namespace: namespace,
        filename: 'features/' + namespace.replace(/\//g, '.') + file,
        feature: feature,
        content: content
      });
    }
    if (add_to_file) {
      namespace = '';
      file = file.replace(/(.*)\//, function(_, $1) {
        namespace = $1 + '/';
        return '';
      });
      result.files.push({
        name: namespace + file,
        namespace: namespace,
        filename: 'files/' + namespace.replace(/\//g, '.') + file,
        content: content
      });
    }
    return comments != null ? comments.filter(function(comment) {
      var _ref1;
      return comment.description.full || comment.description.summary || comment.description.body || ((_ref1 = comment.tags) != null ? _ref1.length : void 0) > 0;
    }) : void 0;
  };

  result = {
    project_title: '',
    ids: {},
    classes: {},
    guides: [],
    pages: {},
    restapis: {},
    features: [],
    files: []
  };

  processParamFlags = function(tag) {
    if (/\[([^\[\]]+)\]/.exec(tag.name)) {
      tag.name = RegExp.$1;
      tag.optional = true;
    }
    if (tag.name.substr(0, 1) === '+') {
      tag.name = tag.name.substr(1);
      tag.addable = true;
    }
    if (tag.name.substr(0, 1) === '-') {
      tag.name = tag.name.substr(1);
      tag.excludable = true;
    }
    return tag;
  };

  findParam = function(params, name) {
    var found, param, _i, _len;
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      param = params[_i];
      if (param.name === name) {
        return param;
      }
      if (param.params) {
        found = findParam(param.params, name);
        if (found) {
          return found;
        }
      }
    }
  };

  makeNested = function(comment, targetName) {
    var i, match, param, parentParam, _results;
    i = comment[targetName].length;
    _results = [];
    while (i-- > 0) {
      param = comment[targetName][i];
      if (match = param.name.match(/\[?([^=]*)\.([^\]]*)\]?/)) {
        parentParam = findParam(comment[targetName], match[1]);
        if (parentParam) {
          comment[targetName].splice(i, 1);
          parentParam[targetName] = parentParam[targetName] || [];
          param.name = match[2];
          _results.push(parentParam[targetName].unshift(param));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  convertLink = function(rel_path, str) {
    if (!str) {
      return '';
    }
    str = str.replace(/\[\[#([^\[\]]+)\]\]/g, function(_, $1) {
      var filename, html_id;
      if (result.ids[$1] && result.ids[$1] !== 'DUPLICATED ENTRY') {
        filename = result.ids[$1].filename + '.html';
        html_id = result.ids[$1].html_id;
        return "<a href='" + rel_path + filename + "#" + html_id + "'>" + $1 + "</a>";
      } else {
        return makeMissingLink($1);
      }
    });
    return str;
  };

  applyMarkdown = function(str) {
    str = str.replace(/#\\#/g, '##');
    return markdown(str);
  };

  classifyComments = function(file, comments) {
    var current_class, current_module;
    current_class = void 0;
    current_module = void 0;
    return comments.forEach(function(comment) {
      var i, id, last, seperator, tag, _i, _len, _ref1;
      comment.defined_in = file;
      comment.ctx || (comment.ctx = {});
      comment.params = [];
      comment.returnprops = [];
      comment.throws = [];
      comment.resterrors = [];
      comment.sees = [];
      comment.todos = [];
      comment["extends"] = [];
      comment.subclasses = [];
      comment.uses = [];
      comment.usedbys = [];
      comment.properties = [];
      comment.examples = [];
      if (comment.ctx.type === 'property' || comment.ctx.type === 'method') {
        id = comment.ctx.string.replace('()', '');
      } else {
        id = comment.ctx.name;
      }
      comment.ctx.fullname = id;
      comment.namespace = '';
      if (comment.ctx.type === 'property' || comment.ctx.type === 'method') {
        if (comment.ctx.cons != null) {
          comment["static"] = false;
          comment.ctx.class_name = comment.ctx.cons;
        } else if (comment.ctx.receiver != null) {
          comment["static"] = true;
          comment.ctx.class_name = comment.ctx.receiver;
        }
      }
      last = 0;
      _ref1 = comment.tags;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        tag = _ref1[i];
        if (tag.type === '') {
          comment.tags[last].string += "\n" + tag.string;
          continue;
        }
        last = i;
        switch (tag.type) {
          case 'page':
          case 'restapi':
          case 'class':
            comment.ctx.type = tag.type;
            if (tag.string) {
              comment.ctx.name = tag.string;
              comment.ctx.fullname = id = comment.ctx.name;
            }
            break;
          case 'module':
            comment.ctx.type = 'class';
            comment.is_module = true;
            if (tag.string) {
              comment.ctx.name = tag.string;
              comment.ctx.fullname = id = comment.ctx.name;
            }
            comment.code = null;
            break;
          case 'memberOf':
            if (/(::|#|prototype)$/.test(tag.parent)) {
              comment["static"] = false;
              comment.ctx.class_name = tag.parent.replace(/(::|#|prototype)$/, '');
            } else {
              comment["static"] = true;
              comment.ctx.class_name = tag.parent;
            }
            break;
          case 'namespace':
            comment.namespace = tag.string ? tag.string + '.' : '';
            break;
          case 'property':
          case 'method':
            comment.ctx.type = tag.type;
            comment.ctx.name = tag.string;
            break;
          case 'static':
            comment["static"] = true;
            break;
          case 'private':
            comment.isPrivate = true;
            break;
          case 'abstract':
            comment.abstract = true;
            break;
          case 'async':
            comment.async = true;
            break;
          case 'param':
          case 'return':
          case 'returnprop':
          case 'throws':
          case 'resterror':
          case 'see':
          case 'extends':
          case 'todo':
          case 'type':
          case 'api':
          case 'uses':
          case 'override':
            break;
          default:
            console.log("Unknown tag : " + tag.type + " in " + file);
        }
      }
      if (comment.ctx.class_name) {
        if (comment.ctx.type === 'function') {
          comment.ctx.type = 'method';
        } else if (comment.ctx.type === 'declaration') {
          comment.ctx.type = 'property';
        }
        seperator = comment["static"] ? '.' : '::';
        id = comment.ctx.class_name + seperator + comment.ctx.name;
        comment.ctx.fullname = comment.ctx.class_name.replace(/.*[\./](\w+)/, '$1') + seperator + comment.ctx.name;
      }
      if (comment.ctx.type === 'class') {
        current_class = comment;
        if (comment.is_module) {
          current_module = comment;
        }
      }
      if ((comment.ctx.type === 'property' || comment.ctx.type === 'method') && !comment.namespace) {
        if (current_class) {
          comment.namespace = current_class.namespace;
        }
        if (current_module && !comment.ctx.class_name) {
          comment.ctx.class_name = current_module.ctx.name;
        }
      }
      if (id) {
        if (result.ids.hasOwnProperty(id)) {
          result.ids[id] = 'DUPLICATED ENTRY';
        } else {
          result.ids[id] = comment;
          result.ids[comment.namespace + id] = comment;
        }
        comment.html_id = (comment.namespace + id).replace(/[^A-Za-z0-9_]/g, '_');
      }
      switch (comment.ctx.type) {
        case 'class':
          comment.ctx.name = comment.namespace + comment.ctx.name;
          comment.ctx.fullname = comment.namespace + comment.ctx.fullname;
          result.classes[comment.ctx.name] = comment;
          if (comment.is_module) {
            return comment.filename = 'modules/' + comment.ctx.name.replace(/\//g, '.');
          } else {
            return comment.filename = 'classes/' + comment.ctx.name.replace(/\//g, '.');
          }
          break;
        case 'property':
        case 'method':
          comment.ctx.class_name = comment.namespace + comment.ctx.class_name;
          return comment.filename = 'classes/' + comment.ctx.class_name.replace(/\//g, '.');
        case 'page':
          return comment.filename = 'pages';
        case 'restapi':
          return comment.filename = 'restapis';
      }
    });
  };

  processComments = function(comments) {
    return comments.forEach(function(comment) {
      var class_comment, class_name, desc, i, str, tag, type, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      desc = comment.description;
      if (desc) {
        desc.full = applyMarkdown(desc.full);
        desc.summary = applyMarkdown(desc.summary);
        desc.body = applyMarkdown(desc.body);
      }
      _ref1 = comment.tags;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tag = _ref1[_i];
        switch (tag.type) {
          case 'param':
            tag = processParamFlags(tag);
            _ref2 = tag.types;
            for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
              type = _ref2[i];
              tag.types[i] = type;
            }
            tag.description = tag.description;
            comment.params.push(tag);
            break;
          case 'return':
            _ref3 = tag.types;
            for (i = _k = 0, _len2 = _ref3.length; _k < _len2; i = ++_k) {
              type = _ref3[i];
              tag.types[i] = type;
            }
            tag.description = tag.description;
            comment["return"] = tag;
            break;
          case 'returnprop':
            tag = dox.parseTag('@param ' + tag.string);
            tag = processParamFlags(tag);
            _ref4 = tag.types;
            for (i = _l = 0, _len3 = _ref4.length; _l < _len3; i = ++_l) {
              type = _ref4[i];
              tag.types[i] = type;
            }
            tag.description = tag.description;
            comment.returnprops.push(tag);
            break;
          case 'throws':
            if (/{([^}]+)}\s*(.*)/.exec(tag.string)) {
              comment.throws.push({
                message: RegExp.$1,
                description: RegExp.$2
              });
            } else {
              comment.throws.push({
                message: tag.string,
                description: ''
              });
            }
            break;
          case 'resterror':
            if (/{(\d+)\/([A-Za-z0-9_ ]+)}\s*(.*)/.exec(tag.string)) {
              comment.resterrors.push({
                code: RegExp.$1,
                message: RegExp.$2,
                description: RegExp.$3
              });
            }
            break;
          case 'see':
            str = tag.local || tag.url;
            comment.sees.push(str);
            break;
          case 'todo':
            comment.todos.push(tag.string);
            break;
          case 'extends':
            comment["extends"].push(tag.string);
            if ((_ref5 = result.ids[tag.string]) != null) {
              _ref5.subclasses.push(comment.ctx.name);
            }
            break;
          case 'uses':
            comment.uses.push(tag.string);
            if ((_ref6 = result.ids[tag.string]) != null) {
              _ref6.usedbys.push(comment.ctx.name);
            }
            break;
          case 'type':
            _ref7 = tag.types;
            for (i = _m = 0, _len4 = _ref7.length; _m < _len4; i = ++_m) {
              type = _ref7[i];
              tag.types[i] = type;
            }
            comment.types = tag.types;
            break;
          case 'example':
            comment.examples.push(tag);
            break;
          case 'override':
            if (result.ids[tag.string] && result.ids[tag.string] !== 'DUPLICATED ENTRY') {
              comment.override = result.ids[tag.string];
            }
            comment.override_link = tag.string;
        }
      }
      if (comment.ctx.type === 'class') {
        if (/^class +\w+ +extends +([\w\.]+)/.exec(comment.code)) {
          comment["extends"].push(RegExp.$1);
          if ((_ref8 = result.ids[RegExp.$1]) != null) {
            _ref8.subclasses.push(comment.ctx.name);
          }
        }
      }
      makeNested(comment, 'params');
      makeNested(comment, 'returnprops');
      switch (comment.ctx.type) {
        case 'property':
        case 'method':
          class_name = comment.ctx.class_name;
          if (class_name && (class_comment = result.classes[class_name])) {
            class_comment.properties.push(comment);
            if (class_comment.is_module) {
              return comment.filename = comment.filename.replace('classes/', 'modules/');
            }
          }
          break;
        case 'page':
          return result.pages[comment.ctx.name] = comment;
        case 'restapi':
          return result.restapis[comment.ctx.name] = comment;
      }
    });
  };

  refineResult = function(result) {
    result.classes = Object.keys(result.classes).sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = result.classes[a].namespace;
      b_ns = result.classes[b].namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      if (a < b) {
        return -1;
      } else {
        return 1;
      }
    }).map(function(name) {
      return result.classes[name];
    });
    result.pages = Object.keys(result.pages).sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = result.pages[a].namespace;
      b_ns = result.pages[b].namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      if (a < b) {
        return -1;
      } else {
        return 1;
      }
    }).map(function(name) {
      return result.pages[name];
    });
    result.restapis = Object.keys(result.restapis).sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = result.restapis[a].namespace;
      b_ns = result.restapis[b].namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      a = a.replace(/([A-Z]+) \/(.*)/, '-$2 $1');
      b = b.replace(/([A-Z]+) \/(.*)/, '-$2 $1');
      if (a < b) {
        return -1;
      } else {
        return 1;
      }
    }).map(function(name) {
      return result.restapis[name];
    });
    result.guides = result.guides.sort(function(a, b) {
      if (a.name < b.name) {
        return -1;
      } else {
        return 1;
      }
    });
    result.features = result.features.sort(function(a, b) {
      if (a.name < b.name) {
        return -1;
      } else {
        return 1;
      }
    });
    result.files = result.files.sort(function(a, b) {
      var a_ns, b_ns;
      a_ns = a.namespace;
      b_ns = b.namespace;
      if (a_ns < b_ns) {
        return -1;
      }
      if (a_ns > b_ns) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      } else {
        return 1;
      }
    });
    result.modules = result.classes.filter(function(klass) {
      return klass.is_module;
    });
    return result.classes = result.classes.filter(function(klass) {
      return !klass.is_module;
    });
  };

  copyResources = function(source, target, callback) {
    var exec;
    exec = require('child_process').exec;
    return exec("rm -rf " + target + "/* ; mkdir -p " + target + " ; cp -a " + source + "/* " + target, function() {
      return callback();
    });
  };

  render = function(result, genopts, options, template, output) {
    options.result = result;
    if (!options.makeTypeLink) {
      options.makeTypeLink = makeTypeLink;
    }
    options.makeSeeLink = makeSeeLink;
    options.convertLink = convertLink;
    options.genopts = genopts;
    options.cache = true;
    return jade.renderFile("" + genopts.templates_dir + "/" + template + ".jade", options, function(error, result) {
      var output_file;
      if (error) {
        return console.error(error.stack);
      }
      output_file = "" + genopts.doc_dir + "/" + output + ".html";
      return fs.writeFile(output_file, result, function(error) {
        if (error) {
          return console.error('failed to create ' + output_file);
        }
        if (!genopts.quite) {
          return console.log(output_file + ' is created');
        }
      });
    });
  };

  renderReadme = function(result, genopts) {
    return fs.readFile("" + (genopts.readme || genopts.project_dir) + "/README.md", 'utf-8', function(error, content) {
      var options;
      if (content) {
        content = applyMarkdown(content);
      }
      options = {
        rel_path: './',
        name: 'README',
        content: content,
        type: 'home'
      };
      return render(result, genopts, options, 'extra', 'index');
    });
  };

  renderGuides = function(result, genopts) {
    if (result.guides.length === 0) {
      return;
    }
    try {
      fs.mkdirSync("" + genopts.doc_dir + "/guides");
    } catch (_error) {}
    return result.guides.forEach(function(guide) {
      var content, options;
      content = guide.content;
      if (content) {
        content = applyMarkdown(content);
      }
      options = {
        rel_path: '../',
        name: guide.name,
        content: content,
        type: 'guides'
      };
      return render(result, genopts, options, 'extra', guide.filename);
    });
  };

  renderPages = function(result, genopts) {
    var options;
    if (result.pages.length > 0) {
      options = {
        rel_path: './',
        name: 'Pages',
        type: 'pages'
      };
      return render(result, genopts, options, 'pages', 'pages');
    }
  };

  renderRESTApis = function(result, genopts) {
    var options;
    if (result.restapis.length > 0) {
      options = {
        rel_path: './',
        name: 'REST APIs',
        type: 'restapis'
      };
      return render(result, genopts, options, 'restapis', 'restapis');
    }
  };

  renderClasses = function(result, genopts) {
    if (result.classes.length === 0) {
      return;
    }
    try {
      fs.mkdirSync("" + genopts.doc_dir + "/classes");
    } catch (_error) {}
    return result.classes.forEach(function(klass) {
      var options, properties;
      properties = klass.properties.sort(function(a, b) {
        if (a.ctx.name < b.ctx.name) {
          return -1;
        } else {
          return 1;
        }
      });
      options = {
        rel_path: '../',
        name: klass.ctx.name,
        klass: klass,
        properties: properties,
        type: 'classes',
        makeTypeLink: function(path, type) {
          return makeTypeLink(path, type, "(in " + klass.defined_in + ")");
        }
      };
      return render(result, genopts, options, 'class', klass.filename);
    });
  };

  renderModules = function(result, genopts) {
    if (result.modules.length === 0) {
      return;
    }
    try {
      fs.mkdirSync("" + genopts.doc_dir + "/modules");
    } catch (_error) {}
    return result.modules.forEach(function(module) {
      var options, properties;
      properties = module.properties.sort(function(a, b) {
        if (a.ctx.name < b.ctx.name) {
          return -1;
        } else {
          return 1;
        }
      });
      options = {
        rel_path: '../',
        name: module.ctx.name,
        module_data: module,
        properties: properties,
        type: 'modules'
      };
      return render(result, genopts, options, 'module', module.filename);
    });
  };

  renderFeatures = function(result, genopts) {
    if (result.features.length === 0) {
      return;
    }
    try {
      fs.mkdirSync("" + genopts.doc_dir + "/features");
    } catch (_error) {}
    return result.features.forEach(function(feature) {
      var options;
      options = {
        rel_path: '../',
        name: feature.name,
        feature: feature,
        type: 'features'
      };
      return render(result, genopts, options, 'feature', feature.filename);
    });
  };

  renderFiles = function(result, genopts) {
    if (result.files.length === 0) {
      return;
    }
    try {
      fs.mkdirSync("" + genopts.doc_dir + "/files");
    } catch (_error) {}
    return result.files.forEach(function(file) {
      var options;
      options = {
        rel_path: '../',
        name: file.name,
        file: file,
        type: 'files'
      };
      return render(result, genopts, options, 'file', file.filename);
    });
  };

  generate = function(paths, genopts) {
    var all_comments, content, e, external_types, file_count_read, output_dir, theme, type, url;
    result.project_title = (genopts != null ? genopts.title : void 0) || 'croquis-jsdoc';
    if (external_types = genopts != null ? genopts['external-types'] : void 0) {
      if (typeof external_types === 'string') {
        try {
          content = fs.readFileSync(external_types, 'utf-8').trim();
          try {
            external_types = JSON.parse(content);
          } catch (_error) {
            e = _error;
            console.log("external-types: Invalid JSON file");
          }
        } catch (_error) {
          e = _error;
          console.log("external-types: Cannot open " + genopts['external-types']);
        }
      }
      if (typeof external_types === 'object') {
        for (type in external_types) {
          url = external_types[type];
          types[type] = url;
        }
      }
    }
    genopts.project_dir = process.cwd();
    output_dir = (genopts != null ? genopts.output : void 0) || 'doc';
    if (output_dir[0] === '/') {
      genopts.doc_dir = output_dir;
    } else {
      genopts.doc_dir = genopts.project_dir + '/' + output_dir;
    }
    theme = 'default';
    genopts.resources_dir = resolve(__dirname, '../themes', theme, 'resources');
    genopts.templates_dir = resolve(__dirname, '../themes', theme, 'templates');
    file_count_read = 0;
    all_comments = [];
    paths.forEach(function(path) {
      var base_path;
      base_path = path = resolve(genopts.project_dir, path);
      while (/[*?]/.test(basename(base_path))) {
        base_path = dirname(base_path);
      }
      return glob.sync(path).forEach(function(path) {
        var list;
        if (fs.statSync(path).isDirectory()) {
          list = walkdir.sync(path);
        } else {
          list = [path];
        }
        return list.forEach(function(file) {
          var comments;
          comments = getComments(file, base_path);
          if (comments == null) {
            return;
          }
          file_count_read++;
          if (!genopts.quite) {
            console.log(file + ' is processed');
          }
          file = file.replace(new RegExp("^" + genopts.project_dir), '');
          classifyComments(file, comments);
          return all_comments.push.apply(all_comments, comments);
        });
      });
    });
    console.log('Total ' + file_count_read + ' files processed');
    processComments(all_comments);
    if (!genopts.files) {
      result.files = [];
    }
    refineResult(result);
    return copyResources(genopts.resources_dir, genopts.doc_dir, function() {
      renderReadme(result, genopts);
      renderGuides(result, genopts);
      renderPages(result, genopts);
      renderRESTApis(result, genopts);
      renderClasses(result, genopts);
      renderModules(result, genopts);
      renderFeatures(result, genopts);
      return renderFiles(result, genopts);
    });
  };

  module.exports = generate;

}).call(this);
